import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getDefaultEmulatorHostnameAndPort,
  getModularInstance,
  registerVersion
} from "./chunk-TXTTIOK3.js";

// node_modules/@firebase/firestore/dist/lite/index.browser.esm2017.js
var d = class {
  constructor(t) {
    this.uid = t;
  }
  isAuthenticated() {
    return null != this.uid;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t) {
    return t.uid === this.uid;
  }
};
d.UNAUTHENTICATED = new d(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
d.GOOGLE_CREDENTIALS = new d("google-credentials-uid"), d.FIRST_PARTY = new d("first-party-uid"), d.MOCK_USER = new d("mock-user");
var w = "9.18.0";
var m = new Logger("@firebase/firestore");
function p(t) {
  m.setLogLevel(t);
}
function y(t, ...e) {
  if (m.logLevel <= LogLevel.DEBUG) {
    const n = e.map(v);
    m.debug(`Firestore (${w}): ${t}`, ...n);
  }
}
function g(t, ...e) {
  if (m.logLevel <= LogLevel.ERROR) {
    const n = e.map(v);
    m.error(`Firestore (${w}): ${t}`, ...n);
  }
}
function _(t, ...e) {
  if (m.logLevel <= LogLevel.WARN) {
    const n = e.map(v);
    m.warn(`Firestore (${w}): ${t}`, ...n);
  }
}
function v(t) {
  if ("string" == typeof t)
    return t;
  try {
    return e = t, JSON.stringify(e);
  } catch (e2) {
    return t;
  }
  var e;
}
function b(t = "Unexpected state") {
  const e = `FIRESTORE (${w}) INTERNAL ASSERTION FAILED: ` + t;
  throw g(e), new Error(e);
}
function E(t, e) {
  t || b();
}
function A(t, e) {
  return t;
}
var I = "ok";
var T = "cancelled";
var R = "unknown";
var P = "invalid-argument";
var V = "deadline-exceeded";
var $ = "not-found";
var D = "already-exists";
var N = "permission-denied";
var F = "unauthenticated";
var x = "resource-exhausted";
var S = "failed-precondition";
var q = "aborted";
var O = "out-of-range";
var k = "unimplemented";
var C = "internal";
var L = "unavailable";
var M = "data-loss";
var U = class extends FirebaseError {
  /** @hideconstructor */
  constructor(t, e) {
    super(t, e), this.code = t, this.message = e, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t, e) => {
      this.resolve = t, this.reject = e;
    });
  }
};
var B = class {
  constructor(t, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t}`);
  }
};
var z = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, e) {
    t.enqueueRetryable(() => e(d.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var Q = class {
  constructor(t) {
    this.token = t, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t, e) {
    this.changeListener = e, // Fire with initial user.
    t.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var W = class {
  constructor(t) {
    this.auth = null, t.onInit((t2) => {
      this.auth = t2;
    });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((t) => t ? (E("string" == typeof t.accessToken), new B(t.accessToken, new d(this.auth.getUid()))) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, e) {
  }
  shutdown() {
  }
};
var G = class {
  constructor(t, e, n, r) {
    this.t = t, this.i = e, this.o = n, this.u = r, this.type = "FirstParty", this.user = d.FIRST_PARTY, this.h = /* @__PURE__ */ new Map();
  }
  /** Gets an authorization token, using a provided factory function, or falling back to First Party GAPI. */
  l() {
    return this.u ? this.u() : (
      // Make sure this really is a Gapi client.
      (E(!("object" != typeof this.t || null === this.t || !this.t.auth || !this.t.auth.getAuthHeaderValueForFirstParty)), this.t.auth.getAuthHeaderValueForFirstParty([]))
    );
  }
  get headers() {
    this.h.set("X-Goog-AuthUser", this.i);
    const t = this.l();
    return t && this.h.set("Authorization", t), this.o && this.h.set("X-Goog-Iam-Authorization-Token", this.o), this.h;
  }
};
var K = class {
  constructor(t, e, n, r) {
    this.t = t, this.i = e, this.o = n, this.u = r;
  }
  getToken() {
    return Promise.resolve(new G(this.t, this.i, this.o, this.u));
  }
  start(t, e) {
    t.enqueueRetryable(() => e(d.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Y = class {
  constructor(t) {
    this.value = t, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t && t.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var H = class {
  constructor(t) {
    this.m = t, this.appCheck = null, t.onInit((t2) => {
      this.appCheck = t2;
    });
  }
  getToken() {
    return this.appCheck ? this.appCheck.getToken().then((t) => t ? (E("string" == typeof t.token), new Y(t.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, e) {
  }
  shutdown() {
  }
};
var Z = class {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(t, e, n, r, s, i, o, u) {
    this.databaseId = t, this.appId = e, this.persistenceKey = n, this.host = r, this.ssl = s, this.forceLongPolling = i, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var J = class _J {
  constructor(t, e) {
    this.projectId = t, this.database = e || "(default)";
  }
  static empty() {
    return new _J("", "");
  }
  get isDefaultDatabase() {
    return "(default)" === this.database;
  }
  isEqual(t) {
    return t instanceof _J && t.projectId === this.projectId && t.database === this.database;
  }
};
var X = class _X {
  constructor(t, e, n) {
    void 0 === e ? e = 0 : e > t.length && b(), void 0 === n ? n = t.length - e : n > t.length - e && b(), this.segments = t, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t) {
    return 0 === _X.comparator(this, t);
  }
  child(t) {
    const e = this.segments.slice(this.offset, this.limit());
    return t instanceof _X ? t.forEach((t2) => {
      e.push(t2);
    }) : e.push(t), this.construct(e);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(t) {
    return t = void 0 === t ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t) {
    return this.segments[this.offset + t];
  }
  isEmpty() {
    return 0 === this.length;
  }
  isPrefixOf(t) {
    if (t.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t) {
    if (this.length + 1 !== t.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t.get(e))
        return false;
    return true;
  }
  forEach(t) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t, e) {
    const n = Math.min(t.length, e.length);
    for (let r = 0; r < n; r++) {
      const n2 = t.get(r), s = e.get(r);
      if (n2 < s)
        return -1;
      if (n2 > s)
        return 1;
    }
    return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;
  }
};
var tt = class _tt extends X {
  construct(t, e, n) {
    return new _tt(t, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...t) {
    const e = [];
    for (const n of t) {
      if (n.indexOf("//") >= 0)
        throw new U(P, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t2) => t2.length > 0));
    }
    return new _tt(e);
  }
  static emptyPath() {
    return new _tt([]);
  }
};
var et = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var nt = class _nt extends X {
  construct(t, e, n) {
    return new _nt(t, e, n);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(t) {
    return et.test(t);
  }
  canonicalString() {
    return this.toArray().map((t) => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), _nt.isValidIdentifier(t) || (t = "`" + t + "`"), t)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return 1 === this.length && "__name__" === this.get(0);
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new _nt(["__name__"]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(t) {
    const e = [];
    let n = "", r = 0;
    const s = () => {
      if (0 === n.length)
        throw new U(P, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let i = false;
    for (; r < t.length; ) {
      const e2 = t[r];
      if ("\\" === e2) {
        if (r + 1 === t.length)
          throw new U(P, "Path has trailing escape character: " + t);
        const e3 = t[r + 1];
        if ("\\" !== e3 && "." !== e3 && "`" !== e3)
          throw new U(P, "Path has invalid escape sequence: " + t);
        n += e3, r += 2;
      } else
        "`" === e2 ? (i = !i, r++) : "." !== e2 || i ? (n += e2, r++) : (s(), r++);
    }
    if (s(), i)
      throw new U(P, "Unterminated ` in path: " + t);
    return new _nt(e);
  }
  static emptyPath() {
    return new _nt([]);
  }
};
var rt = class _rt {
  constructor(t) {
    this.path = t;
  }
  static fromPath(t) {
    return new _rt(tt.fromString(t));
  }
  static fromName(t) {
    return new _rt(tt.fromString(t).popFirst(5));
  }
  static empty() {
    return new _rt(tt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(t) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t) {
    return null !== t && 0 === tt.comparator(this.path, t.path);
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t, e) {
    return tt.comparator(t.path, e.path);
  }
  static isDocumentKey(t) {
    return t.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(t) {
    return new _rt(new tt(t.slice()));
  }
};
function st(t, e, n) {
  if (!n)
    throw new U(P, `Function ${t}() cannot be called with an empty ${e}.`);
}
function it(t) {
  if (!rt.isDocumentKey(t))
    throw new U(P, `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`);
}
function ot(t) {
  if (rt.isDocumentKey(t))
    throw new U(P, `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`);
}
function ut(t) {
  if (void 0 === t)
    return "undefined";
  if (null === t)
    return "null";
  if ("string" == typeof t)
    return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t);
  if ("number" == typeof t || "boolean" == typeof t)
    return "" + t;
  if ("object" == typeof t) {
    if (t instanceof Array)
      return "an array";
    {
      const e = (
        /** try to get the constructor name for an object. */
        function(t2) {
          if (t2.constructor)
            return t2.constructor.name;
          return null;
        }(t)
      );
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return "function" == typeof t ? "a function" : b();
}
function ct(t, e) {
  if ("_delegate" in t && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (t = t._delegate), !(t instanceof e)) {
    if (e.name === t.constructor.name)
      throw new U(P, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = ut(t);
      throw new U(P, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t;
}
function at(t, e) {
  if (e <= 0)
    throw new U(P, `Function ${t}() requires a positive number, but it was: ${e}.`);
}
var ht = null;
function lt() {
  return null === ht ? ht = 268435456 + Math.round(2147483648 * Math.random()) : ht++, "0x" + ht.toString(16);
}
function ft(t) {
  return null == t;
}
function dt(t) {
  return 0 === t && 1 / t == -1 / 0;
}
var wt = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
var mt;
var pt;
function yt(t) {
  if (void 0 === t)
    return g("RPC_ERROR", "HTTP error has no status"), R;
  switch (t) {
    case 200:
      return I;
    case 400:
      return S;
    case 401:
      return F;
    case 403:
      return N;
    case 404:
      return $;
    case 409:
      return q;
    case 416:
      return O;
    case 429:
      return x;
    case 499:
      return T;
    case 500:
      return R;
    case 501:
      return k;
    case 503:
      return L;
    case 504:
      return V;
    default:
      return t >= 200 && t < 300 ? I : t >= 400 && t < 500 ? S : t >= 500 && t < 600 ? C : R;
  }
}
(pt = mt || (mt = {}))[pt.OK = 0] = "OK", pt[pt.CANCELLED = 1] = "CANCELLED", pt[pt.UNKNOWN = 2] = "UNKNOWN", pt[pt.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", pt[pt.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", pt[pt.NOT_FOUND = 5] = "NOT_FOUND", pt[pt.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", pt[pt.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", pt[pt.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", pt[pt.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", pt[pt.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", pt[pt.ABORTED = 10] = "ABORTED", pt[pt.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", pt[pt.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", pt[pt.INTERNAL = 13] = "INTERNAL", pt[pt.UNAVAILABLE = 14] = "UNAVAILABLE", pt[pt.DATA_LOSS = 15] = "DATA_LOSS";
var gt = class extends /**
 * Base class for all Rest-based connections to the backend (WebChannel and
 * HTTP).
 */
class {
  constructor(t) {
    this.databaseInfo = t, this.databaseId = t.databaseId;
    const e = t.ssl ? "https" : "http";
    this.p = e + "://" + t.host, this.g = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  get v() {
    return false;
  }
  A(t, e, n, r, s) {
    const i = lt(), o = this.I(t, e);
    y("RestConnection", `Sending RPC '${t}' ${i}:`, o, n);
    const u = {};
    return this.T(u, r, s), this.R(t, o, u, n).then((e2) => (y("RestConnection", `Received RPC '${t}' ${i}: `, e2), e2), (e2) => {
      throw _("RestConnection", `RPC '${t}' ${i} failed with error: `, e2, "url: ", o, "request:", n), e2;
    });
  }
  P(t, e, n, r, s, i) {
    return this.A(t, e, n, r, s);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  T(t, e, n) {
    t["X-Goog-Api-Client"] = "gl-js/ fire/" + w, // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    t["Content-Type"] = "text/plain", this.databaseInfo.appId && (t["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t[n2] = e2), n && n.headers.forEach((e2, n2) => t[n2] = e2);
  }
  I(t, e) {
    const n = wt[t];
    return `${this.p}/v1/${e}:${n}`;
  }
} {
  /**
   * @param databaseInfo - The connection info.
   * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.
   */
  constructor(t, e) {
    super(t), this.V = e;
  }
  $(t, e) {
    throw new Error("Not supported by FetchConnection");
  }
  async R(t, e, n, r) {
    var s;
    const i = JSON.stringify(r);
    let o;
    try {
      o = await this.V(e, {
        method: "POST",
        headers: n,
        body: i
      });
    } catch (t2) {
      const e2 = t2;
      throw new U(yt(e2.status), "Request failed with error: " + e2.statusText);
    }
    if (!o.ok) {
      let t2 = await o.json();
      Array.isArray(t2) && (t2 = t2[0]);
      const e2 = null === (s = null == t2 ? void 0 : t2.error) || void 0 === s ? void 0 : s.message;
      throw new U(yt(o.status), `Request failed with error: ${null != e2 ? e2 : o.statusText}`);
    }
    return o.json();
  }
};
var _t = /^[_a-zA-Z][_a-zA-Z0-9]*(?:\.[_a-zA-Z][_a-zA-Z0-9]*)*$/;
var vt = class _vt {
  /**
   * @internal
   * @param alias Un-escaped alias representation
   */
  constructor(t) {
    this.alias = t;
  }
  /**
   * Returns true if the string could be used as an alias.
   */
  static D(t) {
    return _t.test(t);
  }
  /**
   * Return an escaped and quoted string representation of the alias.
   */
  canonicalString() {
    let t = this.alias.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
    return _vt.D(t) || (t = "`" + t + "`"), t;
  }
};
var bt = class {
  constructor(t, e, n) {
    this.alias = t, this.N = e, this.fieldPath = n;
  }
};
function Et(t) {
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "undefined" != typeof self && (self.crypto || self.msCrypto)
  ), n = new Uint8Array(t);
  if (e && "function" == typeof e.getRandomValues)
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
var At = class {
  static F() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t.length) * t.length;
    let n = "";
    for (; n.length < 20; ) {
      const r = Et(40);
      for (let s = 0; s < r.length; ++s)
        n.length < 20 && r[s] < e && (n += t.charAt(r[s] % t.length));
    }
    return n;
  }
};
function It(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Tt(t, e, n) {
  return t.length === e.length && t.every((t2, r) => n(t2, e[r]));
}
function Rt(t) {
  let e = 0;
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e++;
  return e;
}
function Pt(t, e) {
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);
}
var Vt = class extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
};
var $t = class _$t {
  constructor(t) {
    this.binaryString = t;
  }
  static fromBase64String(t) {
    const e = function(t2) {
      try {
        return atob(t2);
      } catch (t3) {
        throw t3 instanceof DOMException ? new Vt("Invalid base64 string: " + t3) : t3;
      }
    }(t);
    return new _$t(e);
  }
  static fromUint8Array(t) {
    const e = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function(t2) {
        let e2 = "";
        for (let n = 0; n < t2.length; ++n)
          e2 += String.fromCharCode(t2[n]);
        return e2;
      }(t)
    );
    return new _$t(e);
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t = this.binaryString, btoa(t);
    var t;
  }
  toUint8Array() {
    return function(t) {
      const e = new Uint8Array(t.length);
      for (let n = 0; n < t.length; n++)
        e[n] = t.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t) {
    return It(this.binaryString, t.binaryString);
  }
  isEqual(t) {
    return this.binaryString === t.binaryString;
  }
};
$t.EMPTY_BYTE_STRING = new $t("");
var Dt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Nt(t) {
  if (E(!!t), "string" == typeof t) {
    let e = 0;
    const n = Dt.exec(t);
    if (E(!!n), n[1]) {
      let t2 = n[1];
      t2 = (t2 + "000000000").substr(0, 9), e = Number(t2);
    }
    const r = new Date(t);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Ft(t.seconds),
    nanos: Ft(t.nanos)
  };
}
function Ft(t) {
  return "number" == typeof t ? t : "string" == typeof t ? Number(t) : 0;
}
function xt(t) {
  return "string" == typeof t ? $t.fromBase64String(t) : $t.fromUint8Array(t);
}
var St = class _St {
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(t, e) {
    if (this.seconds = t, this.nanoseconds = e, e < 0)
      throw new U(P, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new U(P, "Timestamp nanoseconds out of range: " + e);
    if (t < -62135596800)
      throw new U(P, "Timestamp seconds out of range: " + t);
    if (t >= 253402300800)
      throw new U(P, "Timestamp seconds out of range: " + t);
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return _St.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(t) {
    return _St.fromMillis(t.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(t) {
    const e = Math.floor(t / 1e3), n = Math.floor(1e6 * (t - 1e3 * e));
    return new _St(e, n);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t) {
    return this.seconds === t.seconds ? It(this.nanoseconds, t.nanoseconds) : It(this.seconds, t.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(t) {
    return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const t = this.seconds - -62135596800;
    return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
function qt(t) {
  var e, n;
  return "server_timestamp" === (null === (n = ((null === (e = null == t ? void 0 : t.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue);
}
function Ot(t) {
  const e = t.mapValue.fields.__previous_value__;
  return qt(e) ? Ot(e) : e;
}
function kt(t) {
  const e = Nt(t.mapValue.fields.__local_write_time__.timestampValue);
  return new St(e.seconds, e.nanos);
}
var Ct = {
  fields: {
    __type__: {
      stringValue: "__max__"
    }
  }
};
function Lt(t) {
  return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? qt(t) ? 4 : (
    /** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */
    function(t2) {
      return "__max__" === (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue;
    }(t) ? 9007199254740991 : 10
  ) : b();
}
function Mt(t, e) {
  if (t === e)
    return true;
  const n = Lt(t);
  if (n !== Lt(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t.booleanValue === e.booleanValue;
    case 4:
      return kt(t).isEqual(kt(e));
    case 3:
      return function(t2, e2) {
        if ("string" == typeof t2.timestampValue && "string" == typeof e2.timestampValue && t2.timestampValue.length === e2.timestampValue.length)
          return t2.timestampValue === e2.timestampValue;
        const n2 = Nt(t2.timestampValue), r = Nt(e2.timestampValue);
        return n2.seconds === r.seconds && n2.nanos === r.nanos;
      }(t, e);
    case 5:
      return t.stringValue === e.stringValue;
    case 6:
      return function(t2, e2) {
        return xt(t2.bytesValue).isEqual(xt(e2.bytesValue));
      }(t, e);
    case 7:
      return t.referenceValue === e.referenceValue;
    case 8:
      return function(t2, e2) {
        return Ft(t2.geoPointValue.latitude) === Ft(e2.geoPointValue.latitude) && Ft(t2.geoPointValue.longitude) === Ft(e2.geoPointValue.longitude);
      }(t, e);
    case 2:
      return function(t2, e2) {
        if ("integerValue" in t2 && "integerValue" in e2)
          return Ft(t2.integerValue) === Ft(e2.integerValue);
        if ("doubleValue" in t2 && "doubleValue" in e2) {
          const n2 = Ft(t2.doubleValue), r = Ft(e2.doubleValue);
          return n2 === r ? dt(n2) === dt(r) : isNaN(n2) && isNaN(r);
        }
        return false;
      }(t, e);
    case 9:
      return Tt(t.arrayValue.values || [], e.arrayValue.values || [], Mt);
    case 10:
      return function(t2, e2) {
        const n2 = t2.mapValue.fields || {}, r = e2.mapValue.fields || {};
        if (Rt(n2) !== Rt(r))
          return false;
        for (const t3 in n2)
          if (n2.hasOwnProperty(t3) && (void 0 === r[t3] || !Mt(n2[t3], r[t3])))
            return false;
        return true;
      }(t, e);
    default:
      return b();
  }
}
function Ut(t, e) {
  return void 0 !== (t.values || []).find((t2) => Mt(t2, e));
}
function jt(t, e) {
  if (t === e)
    return 0;
  const n = Lt(t), r = Lt(e);
  if (n !== r)
    return It(n, r);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return It(t.booleanValue, e.booleanValue);
    case 2:
      return function(t2, e2) {
        const n2 = Ft(t2.integerValue || t2.doubleValue), r2 = Ft(e2.integerValue || e2.doubleValue);
        return n2 < r2 ? -1 : n2 > r2 ? 1 : n2 === r2 ? 0 : (
          // one or both are NaN.
          isNaN(n2) ? isNaN(r2) ? 0 : -1 : 1
        );
      }(t, e);
    case 3:
      return Bt(t.timestampValue, e.timestampValue);
    case 4:
      return Bt(kt(t), kt(e));
    case 5:
      return It(t.stringValue, e.stringValue);
    case 6:
      return function(t2, e2) {
        const n2 = xt(t2), r2 = xt(e2);
        return n2.compareTo(r2);
      }(t.bytesValue, e.bytesValue);
    case 7:
      return function(t2, e2) {
        const n2 = t2.split("/"), r2 = e2.split("/");
        for (let t3 = 0; t3 < n2.length && t3 < r2.length; t3++) {
          const e3 = It(n2[t3], r2[t3]);
          if (0 !== e3)
            return e3;
        }
        return It(n2.length, r2.length);
      }(t.referenceValue, e.referenceValue);
    case 8:
      return function(t2, e2) {
        const n2 = It(Ft(t2.latitude), Ft(e2.latitude));
        if (0 !== n2)
          return n2;
        return It(Ft(t2.longitude), Ft(e2.longitude));
      }(t.geoPointValue, e.geoPointValue);
    case 9:
      return function(t2, e2) {
        const n2 = t2.values || [], r2 = e2.values || [];
        for (let t3 = 0; t3 < n2.length && t3 < r2.length; ++t3) {
          const e3 = jt(n2[t3], r2[t3]);
          if (e3)
            return e3;
        }
        return It(n2.length, r2.length);
      }(t.arrayValue, e.arrayValue);
    case 10:
      return function(t2, e2) {
        if (t2 === Ct && e2 === Ct)
          return 0;
        if (t2 === Ct)
          return 1;
        if (e2 === Ct)
          return -1;
        const n2 = t2.fields || {}, r2 = Object.keys(n2), s = e2.fields || {}, i = Object.keys(s);
        r2.sort(), i.sort();
        for (let t3 = 0; t3 < r2.length && t3 < i.length; ++t3) {
          const e3 = It(r2[t3], i[t3]);
          if (0 !== e3)
            return e3;
          const o = jt(n2[r2[t3]], s[i[t3]]);
          if (0 !== o)
            return o;
        }
        return It(r2.length, i.length);
      }(t.mapValue, e.mapValue);
    default:
      throw b();
  }
}
function Bt(t, e) {
  if ("string" == typeof t && "string" == typeof e && t.length === e.length)
    return It(t, e);
  const n = Nt(t), r = Nt(e), s = It(n.seconds, r.seconds);
  return 0 !== s ? s : It(n.nanos, r.nanos);
}
function zt(t, e) {
  return {
    referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${e.path.canonicalString()}`
  };
}
function Qt(t) {
  return !!t && "arrayValue" in t;
}
function Wt(t) {
  return !!t && "nullValue" in t;
}
function Gt(t) {
  return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue));
}
function Kt(t) {
  return !!t && "mapValue" in t;
}
function Yt(t) {
  if (t.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t.geoPointValue)
    };
  if (t.timestampValue && "object" == typeof t.timestampValue)
    return {
      timestampValue: Object.assign({}, t.timestampValue)
    };
  if (t.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return Pt(t.mapValue.fields, (t2, n) => e.mapValue.fields[t2] = Yt(n)), e;
  }
  if (t.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Yt(t.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t);
}
var Ht = class {
  constructor(t, e) {
    this.position = t, this.inclusive = e;
  }
};
function Zt(t, e) {
  if (null === t)
    return null === e;
  if (null === e)
    return false;
  if (t.inclusive !== e.inclusive || t.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t.position.length; n++) {
    if (!Mt(t.position[n], e.position[n]))
      return false;
  }
  return true;
}
var Jt = class {
};
var Xt = class _Xt extends Jt {
  constructor(t, e, n) {
    super(), this.field = t, this.op = e, this.value = n;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(t, e, n) {
    return t.isKeyField() ? "in" === e || "not-in" === e ? this.createKeyFieldInFilter(t, e, n) : new ne(t, e, n) : "array-contains" === e ? new oe(t, n) : "in" === e ? new ue(t, n) : "not-in" === e ? new ce(t, n) : "array-contains-any" === e ? new ae(t, n) : new _Xt(t, e, n);
  }
  static createKeyFieldInFilter(t, e, n) {
    return "in" === e ? new re(t, n) : new se(t, n);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return "!=" === this.op ? null !== e && this.matchesComparison(jt(e, this.value)) : null !== e && Lt(this.value) === Lt(e) && this.matchesComparison(jt(e, this.value));
  }
  matchesComparison(t) {
    switch (this.op) {
      case "<":
        return t < 0;
      case "<=":
        return t <= 0;
      case "==":
        return 0 === t;
      case "!=":
        return 0 !== t;
      case ">":
        return t > 0;
      case ">=":
        return t >= 0;
      default:
        return b();
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
  getFirstInequalityField() {
    return this.isInequality() ? this.field : null;
  }
};
var te = class _te extends Jt {
  constructor(t, e) {
    super(), this.filters = t, this.op = e, this.S = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(t, e) {
    return new _te(t, e);
  }
  matches(t) {
    return "and" === this.op ? void 0 === this.filters.find((e) => !e.matches(t)) : void 0 !== this.filters.find((e) => e.matches(t));
  }
  getFlattenedFilters() {
    return null !== this.S || (this.S = this.filters.reduce((t, e) => t.concat(e.getFlattenedFilters()), [])), this.S;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
  getFirstInequalityField() {
    const t = this.q((t2) => t2.isInequality());
    return null !== t ? t.field : null;
  }
  // Performs a depth-first search to find and return the first FieldFilter in the composite filter
  // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the
  // predicate.
  q(t) {
    for (const e of this.getFlattenedFilters())
      if (t(e))
        return e;
    return null;
  }
};
function ee(t, e) {
  return t instanceof Xt ? function(t2, e2) {
    return e2 instanceof Xt && t2.op === e2.op && t2.field.isEqual(e2.field) && Mt(t2.value, e2.value);
  }(t, e) : t instanceof te ? function(t2, e2) {
    if (e2 instanceof te && t2.op === e2.op && t2.filters.length === e2.filters.length) {
      return t2.filters.reduce((t3, n, r) => t3 && ee(n, e2.filters[r]), true);
    }
    return false;
  }(t, e) : void b();
}
var ne = class extends Xt {
  constructor(t, e, n) {
    super(t, e, n), this.key = rt.fromName(n.referenceValue);
  }
  matches(t) {
    const e = rt.comparator(t.key, this.key);
    return this.matchesComparison(e);
  }
};
var re = class extends Xt {
  constructor(t, e) {
    super(t, "in", e), this.keys = ie("in", e);
  }
  matches(t) {
    return this.keys.some((e) => e.isEqual(t.key));
  }
};
var se = class extends Xt {
  constructor(t, e) {
    super(t, "not-in", e), this.keys = ie("not-in", e);
  }
  matches(t) {
    return !this.keys.some((e) => e.isEqual(t.key));
  }
};
function ie(t, e) {
  var n;
  return ((null === (n = e.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((t2) => rt.fromName(t2.referenceValue));
}
var oe = class extends Xt {
  constructor(t, e) {
    super(t, "array-contains", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return Qt(e) && Ut(e.arrayValue, this.value);
  }
};
var ue = class extends Xt {
  constructor(t, e) {
    super(t, "in", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return null !== e && Ut(this.value.arrayValue, e);
  }
};
var ce = class extends Xt {
  constructor(t, e) {
    super(t, "not-in", e);
  }
  matches(t) {
    if (Ut(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t.data.field(this.field);
    return null !== e && !Ut(this.value.arrayValue, e);
  }
};
var ae = class extends Xt {
  constructor(t, e) {
    super(t, "array-contains-any", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return !(!Qt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t2) => Ut(this.value.arrayValue, t2));
  }
};
var he = class {
  constructor(t, e = "asc") {
    this.field = t, this.dir = e;
  }
};
function le(t, e) {
  return t.dir === e.dir && t.field.isEqual(e.field);
}
var fe = class _fe {
  constructor(t) {
    this.timestamp = t;
  }
  static fromTimestamp(t) {
    return new _fe(t);
  }
  static min() {
    return new _fe(new St(0, 0));
  }
  static max() {
    return new _fe(new St(253402300799, 999999999));
  }
  compareTo(t) {
    return this.timestamp._compareTo(t.timestamp);
  }
  isEqual(t) {
    return this.timestamp.isEqual(t.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
var de = class _de {
  constructor(t, e) {
    this.comparator = t, this.root = e || me.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(t, e) {
    return new _de(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, me.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(t) {
    return new _de(this.comparator, this.root.remove(t, this.comparator).copy(null, null, me.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(t) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t, e.key);
      if (0 === n)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(t) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const r = this.comparator(t, n.key);
      if (0 === r)
        return e + n.left.size;
      r < 0 ? n = n.left : (
        // Count all nodes left of the node plus the node itself
        (e += n.left.size + 1, n = n.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(t) {
    return this.root.inorderTraversal(t);
  }
  forEach(t) {
    this.inorderTraversal((e, n) => (t(e, n), false));
  }
  toString() {
    const t = [];
    return this.inorderTraversal((e, n) => (t.push(`${e}:${n}`), false)), `{${t.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(t) {
    return this.root.reverseTraversal(t);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new we(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t) {
    return new we(this.root, t, this.comparator, false);
  }
  getReverseIterator() {
    return new we(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t) {
    return new we(this.root, t, this.comparator, true);
  }
};
var we = class {
  constructor(t, e, n, r) {
    this.isReverse = r, this.nodeStack = [];
    let s = 1;
    for (; !t.isEmpty(); )
      if (s = e ? n(t.key, e) : 1, // flip the comparison if we're going in reverse
      e && r && (s *= -1), s < 0)
        t = this.isReverse ? t.left : t.right;
      else {
        if (0 === s) {
          this.nodeStack.push(t);
          break;
        }
        this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;
      }
  }
  getNext() {
    let t = this.nodeStack.pop();
    const e = {
      key: t.key,
      value: t.value
    };
    if (this.isReverse)
      for (t = t.left; !t.isEmpty(); )
        this.nodeStack.push(t), t = t.right;
    else
      for (t = t.right; !t.isEmpty(); )
        this.nodeStack.push(t), t = t.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (0 === this.nodeStack.length)
      return null;
    const t = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t.key,
      value: t.value
    };
  }
};
var me = class _me {
  constructor(t, e, n, r, s) {
    this.key = t, this.value = e, this.color = null != n ? n : _me.RED, this.left = null != r ? r : _me.EMPTY, this.right = null != s ? s : _me.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(t, e, n, r, s) {
    return new _me(null != t ? t : this.key, null != e ? e : this.value, null != n ? n : this.color, null != r ? r : this.left, null != s ? s : this.right);
  }
  isEmpty() {
    return false;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(t) {
    return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(t) {
    return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(t, e, n) {
    let r = this;
    const s = n(t, r.key);
    return r = s < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : 0 === s ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n)), r.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return _me.EMPTY;
    let t = this;
    return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(t, e) {
    let n, r = this;
    if (e(t, r.key) < 0)
      r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);
    else {
      if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === e(t, r.key)) {
        if (r.right.isEmpty())
          return _me.EMPTY;
        n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());
      }
      r = r.copy(null, null, null, null, r.right.remove(t, e));
    }
    return r.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let t = this;
    return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;
  }
  moveRedLeft() {
    let t = this.colorFlip();
    return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t;
  }
  moveRedRight() {
    let t = this.colorFlip();
    return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t;
  }
  rotateLeft() {
    const t = this.copy(null, null, _me.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t, null);
  }
  rotateRight() {
    const t = this.copy(null, null, _me.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t);
  }
  colorFlip() {
    const t = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t, e);
  }
  // For testing.
  checkMaxDepth() {
    const t = this.check();
    return Math.pow(2, t) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed())
      throw b();
    if (this.right.isRed())
      throw b();
    const t = this.left.check();
    if (t !== this.right.check())
      throw b();
    return t + (this.isRed() ? 0 : 1);
  }
};
me.EMPTY = null, me.RED = true, me.BLACK = false;
me.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw b();
  }
  get value() {
    throw b();
  }
  get color() {
    throw b();
  }
  get left() {
    throw b();
  }
  get right() {
    throw b();
  }
  // Returns a copy of the current node.
  copy(t, e, n, r, s) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(t, e, n) {
    return new me(t, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(t, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t) {
    return false;
  }
  reverseTraversal(t) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  // For testing.
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var pe = class _pe {
  constructor(t) {
    this.comparator = t, this.data = new de(this.comparator);
  }
  has(t) {
    return null !== this.data.get(t);
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t) {
    return this.data.indexOf(t);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(t) {
    this.data.inorderTraversal((e, n) => (t(e), false));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(t, e) {
    const n = this.data.getIteratorFrom(t[0]);
    for (; n.hasNext(); ) {
      const r = n.getNext();
      if (this.comparator(r.key, t[1]) >= 0)
        return;
      e(r.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(t, e) {
    let n;
    for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t(n.getNext().key))
        return;
    }
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(t) {
    const e = this.data.getIteratorFrom(t);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new ye(this.data.getIterator());
  }
  getIteratorFrom(t) {
    return new ye(this.data.getIteratorFrom(t));
  }
  /** Inserts or updates an element */
  add(t) {
    return this.copy(this.data.remove(t).insert(t, true));
  }
  /** Deletes an element */
  delete(t) {
    return this.has(t) ? this.copy(this.data.remove(t)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t) {
    let e = this;
    return e.size < t.size && (e = t, t = this), t.forEach((t2) => {
      e = e.add(t2);
    }), e;
  }
  isEqual(t) {
    if (!(t instanceof _pe))
      return false;
    if (this.size !== t.size)
      return false;
    const e = this.data.getIterator(), n = t.data.getIterator();
    for (; e.hasNext(); ) {
      const t2 = e.getNext().key, r = n.getNext().key;
      if (0 !== this.comparator(t2, r))
        return false;
    }
    return true;
  }
  toArray() {
    const t = [];
    return this.forEach((e) => {
      t.push(e);
    }), t;
  }
  toString() {
    const t = [];
    return this.forEach((e) => t.push(e)), "SortedSet(" + t.toString() + ")";
  }
  copy(t) {
    const e = new _pe(this.comparator);
    return e.data = t, e;
  }
};
var ye = class {
  constructor(t) {
    this.iter = t;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var ge = class _ge {
  constructor(t) {
    this.fields = t, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    t.sort(nt.comparator);
  }
  static empty() {
    return new _ge([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(t) {
    let e = new pe(nt.comparator);
    for (const t2 of this.fields)
      e = e.add(t2);
    for (const n of t)
      e = e.add(n);
    return new _ge(e.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(t) {
    for (const e of this.fields)
      if (e.isPrefixOf(t))
        return true;
    return false;
  }
  isEqual(t) {
    return Tt(this.fields, t.fields, (t2, e) => t2.isEqual(e));
  }
};
var _e = class __e {
  constructor(t) {
    this.value = t;
  }
  static empty() {
    return new __e({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(t) {
    if (t.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t.get(n)], !Kt(e))
          return null;
      return e = (e.mapValue.fields || {})[t.lastSegment()], e || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(t, e) {
    this.getFieldsMap(t.popLast())[t.lastSegment()] = Yt(e);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(t) {
    let e = nt.emptyPath(), n = {}, r = [];
    t.forEach((t2, s2) => {
      if (!e.isImmediateParentOf(s2)) {
        const t3 = this.getFieldsMap(e);
        this.applyChanges(t3, n, r), n = {}, r = [], e = s2.popLast();
      }
      t2 ? n[s2.lastSegment()] = Yt(t2) : r.push(s2.lastSegment());
    });
    const s = this.getFieldsMap(e);
    this.applyChanges(s, n, r);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(t) {
    const e = this.field(t.popLast());
    Kt(e) && e.mapValue.fields && delete e.mapValue.fields[t.lastSegment()];
  }
  isEqual(t) {
    return Mt(this.value, t.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(t) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t.length; ++n) {
      let r = e.mapValue.fields[t.get(n)];
      Kt(r) && r.mapValue.fields || (r = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t.get(n)] = r), e = r;
    }
    return e.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(t, e, n) {
    Pt(e, (e2, n2) => t[e2] = n2);
    for (const e2 of n)
      delete t[e2];
  }
  clone() {
    return new __e(Yt(this.value));
  }
};
var ve = class _ve {
  constructor(t, e, n, r, s, i, o) {
    this.key = t, this.documentType = e, this.version = n, this.readTime = r, this.createTime = s, this.data = i, this.documentState = o;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(t) {
    return new _ve(
      t,
      0,
      /* version */
      fe.min(),
      /* readTime */
      fe.min(),
      /* createTime */
      fe.min(),
      _e.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(t, e, n, r) {
    return new _ve(
      t,
      1,
      /* version */
      e,
      /* readTime */
      fe.min(),
      /* createTime */
      n,
      r,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(t, e) {
    return new _ve(
      t,
      2,
      /* version */
      e,
      /* readTime */
      fe.min(),
      /* createTime */
      fe.min(),
      _e.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(t, e) {
    return new _ve(
      t,
      3,
      /* version */
      e,
      /* readTime */
      fe.min(),
      /* createTime */
      fe.min(),
      _e.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(t, e) {
    return !this.createTime.isEqual(fe.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = t), this.version = t, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(t) {
    return this.version = t, this.documentType = 2, this.data = _e.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(t) {
    return this.version = t, this.documentType = 3, this.data = _e.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = fe.min(), this;
  }
  setReadTime(t) {
    return this.readTime = t, this;
  }
  get hasLocalMutations() {
    return 1 === this.documentState;
  }
  get hasCommittedMutations() {
    return 2 === this.documentState;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return 0 !== this.documentType;
  }
  isFoundDocument() {
    return 1 === this.documentType;
  }
  isNoDocument() {
    return 2 === this.documentType;
  }
  isUnknownDocument() {
    return 3 === this.documentType;
  }
  isEqual(t) {
    return t instanceof _ve && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data);
  }
  mutableCopy() {
    return new _ve(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var be = class {
  constructor(t, e = null, n = [], r = [], s = null, i = null, o = null) {
    this.path = t, this.collectionGroup = e, this.orderBy = n, this.filters = r, this.limit = s, this.startAt = i, this.endAt = o, this.O = null;
  }
};
function Ee(t, e = null, n = [], r = [], s = null, i = null, o = null) {
  return new be(t, e, n, r, s, i, o);
}
var Ae = class {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(t, e = null, n = [], r = [], s = null, i = "F", o = null, u = null) {
    this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = r, this.limit = s, this.limitType = i, this.startAt = o, this.endAt = u, this.k = null, // The corresponding `Target` of this `Query` instance.
    this.C = null, this.startAt, this.endAt;
  }
};
function Ie(t) {
  return t.explicitOrderBy.length > 0 ? t.explicitOrderBy[0].field : null;
}
function Te(t) {
  for (const e of t.filters) {
    const t2 = e.getFirstInequalityField();
    if (null !== t2)
      return t2;
  }
  return null;
}
function Re(t) {
  return null !== t.collectionGroup;
}
function Pe(t) {
  const e = A(t);
  if (null === e.k) {
    e.k = [];
    const t2 = Te(e), n = Ie(e);
    if (null !== t2 && null === n)
      t2.isKeyField() || e.k.push(new he(t2)), e.k.push(new he(
        nt.keyField(),
        "asc"
        /* Direction.ASCENDING */
      ));
    else {
      let t3 = false;
      for (const n2 of e.explicitOrderBy)
        e.k.push(n2), n2.field.isKeyField() && (t3 = true);
      if (!t3) {
        const t4 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.k.push(new he(nt.keyField(), t4));
      }
    }
  }
  return e.k;
}
function Ve(t) {
  const e = A(t);
  if (!e.C)
    if ("F" === e.limitType)
      e.C = Ee(e.path, e.collectionGroup, Pe(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t2 = [];
      for (const n2 of Pe(e)) {
        const e2 = "desc" === n2.dir ? "asc" : "desc";
        t2.push(new he(n2.field, e2));
      }
      const n = e.endAt ? new Ht(e.endAt.position, e.endAt.inclusive) : null, r = e.startAt ? new Ht(e.startAt.position, e.startAt.inclusive) : null;
      e.C = Ee(e.path, e.collectionGroup, t2, e.filters, e.limit, n, r);
    }
  return e.C;
}
function $e(t, e) {
  e.getFirstInequalityField(), Te(t);
  const n = t.filters.concat([e]);
  return new Ae(t.path, t.collectionGroup, t.explicitOrderBy.slice(), n, t.limit, t.limitType, t.startAt, t.endAt);
}
function De(t, e) {
  return function(t2, e2) {
    if (t2.limit !== e2.limit)
      return false;
    if (t2.orderBy.length !== e2.orderBy.length)
      return false;
    for (let n = 0; n < t2.orderBy.length; n++)
      if (!le(t2.orderBy[n], e2.orderBy[n]))
        return false;
    if (t2.filters.length !== e2.filters.length)
      return false;
    for (let n = 0; n < t2.filters.length; n++)
      if (!ee(t2.filters[n], e2.filters[n]))
        return false;
    return t2.collectionGroup === e2.collectionGroup && !!t2.path.isEqual(e2.path) && !!Zt(t2.startAt, e2.startAt) && Zt(t2.endAt, e2.endAt);
  }(Ve(t), Ve(e)) && t.limitType === e.limitType;
}
function Ne(t, e) {
  return function(t2) {
    return "number" == typeof t2 && Number.isInteger(t2) && !dt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
  }(e) ? (
    /**
    * Returns an IntegerValue for `value`.
    */
    function(t2) {
      return {
        integerValue: "" + t2
      };
    }(e)
  ) : function(t2, e2) {
    if (t2.L) {
      if (isNaN(e2))
        return {
          doubleValue: "NaN"
        };
      if (e2 === 1 / 0)
        return {
          doubleValue: "Infinity"
        };
      if (e2 === -1 / 0)
        return {
          doubleValue: "-Infinity"
        };
    }
    return {
      doubleValue: dt(e2) ? "-0" : e2
    };
  }(t, e);
}
var Fe = class {
  constructor() {
    this._ = void 0;
  }
};
var xe = class extends Fe {
};
var Se = class extends Fe {
  constructor(t) {
    super(), this.elements = t;
  }
};
var qe = class extends Fe {
  constructor(t) {
    super(), this.elements = t;
  }
};
var Oe = class extends Fe {
  constructor(t, e) {
    super(), this.M = t, this.U = e;
  }
};
var ke = class {
  constructor(t, e) {
    this.field = t, this.transform = e;
  }
};
var Ce = class _Ce {
  constructor(t, e) {
    this.updateTime = t, this.exists = e;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new _Ce();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(t) {
    return new _Ce(void 0, t);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(t) {
    return new _Ce(t);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return void 0 === this.updateTime && void 0 === this.exists;
  }
  isEqual(t) {
    return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime);
  }
};
var Le = class {
};
var Me = class extends Le {
  constructor(t, e, n, r = []) {
    super(), this.key = t, this.value = e, this.precondition = n, this.fieldTransforms = r, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
};
var Ue = class extends Le {
  constructor(t, e, n, r, s = []) {
    super(), this.key = t, this.data = e, this.fieldMask = n, this.precondition = r, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
};
var je = class extends Le {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Be = class extends Le {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var ze = (() => {
  const t = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t;
})();
var Qe = (() => {
  const t = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t;
})();
var We = (() => {
  const t = {
    and: "AND",
    or: "OR"
  };
  return t;
})();
var Ge = class {
  constructor(t, e) {
    this.databaseId = t, this.L = e;
  }
};
function Ke(t, e) {
  if (t.L) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Ye(t, e) {
  return t.L ? e.toBase64() : e.toUint8Array();
}
function He(t, e) {
  return Ke(t, e.toTimestamp());
}
function Ze(t) {
  return E(!!t), fe.fromTimestamp(function(t2) {
    const e = Nt(t2);
    return new St(e.seconds, e.nanos);
  }(t));
}
function Je(t, e) {
  return function(t2) {
    return new tt(["projects", t2.projectId, "databases", t2.database]);
  }(t).child("documents").child(e).canonicalString();
}
function Xe(t, e) {
  return Je(t.databaseId, e.path);
}
function tn(t, e) {
  const n = function(t2) {
    const e2 = tt.fromString(t2);
    return E(wn(e2)), e2;
  }(e);
  if (n.get(1) !== t.databaseId.projectId)
    throw new U(P, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t.databaseId.projectId);
  if (n.get(3) !== t.databaseId.database)
    throw new U(P, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t.databaseId.database);
  return new rt((E((r = n).length > 4 && "documents" === r.get(4)), r.popFirst(5)));
  var r;
}
function en(t, e) {
  return Je(t.databaseId, e);
}
function nn(t) {
  return new tt(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString();
}
function rn(t, e, n) {
  return {
    name: Xe(t, e),
    fields: n.value.mapValue.fields
  };
}
function sn(t, e) {
  return "found" in e ? function(t2, e2) {
    E(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = tn(t2, e2.found.name), r = Ze(e2.found.updateTime), s = e2.found.createTime ? Ze(e2.found.createTime) : fe.min(), i = new _e({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return ve.newFoundDocument(n, r, s, i);
  }(t, e) : "missing" in e ? function(t2, e2) {
    E(!!e2.missing), E(!!e2.readTime);
    const n = tn(t2, e2.missing), r = Ze(e2.readTime);
    return ve.newNoDocument(n, r);
  }(t, e) : b();
}
function on(t, e) {
  let n;
  if (e instanceof Me)
    n = {
      update: rn(t, e.key, e.value)
    };
  else if (e instanceof je)
    n = {
      delete: Xe(t, e.key)
    };
  else if (e instanceof Ue)
    n = {
      update: rn(t, e.key, e.data),
      updateMask: dn(e.fieldMask)
    };
  else {
    if (!(e instanceof Be))
      return b();
    n = {
      verify: Xe(t, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t2) => function(t3, e2) {
    const n2 = e2.transform;
    if (n2 instanceof xe)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Se)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof qe)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Oe)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.U
      };
    throw b();
  }(0, t2))), e.precondition.isNone || (n.currentDocument = function(t2, e2) {
    return void 0 !== e2.updateTime ? {
      updateTime: He(t2, e2.updateTime)
    } : void 0 !== e2.exists ? {
      exists: e2.exists
    } : b();
  }(t, e.precondition)), n;
}
function un(t, e) {
  const n = {
    structuredQuery: {}
  }, r = e.path;
  null !== e.collectionGroup ? (n.parent = en(t, r), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = en(t, r.popLast()), n.structuredQuery.from = [{
    collectionId: r.lastSegment()
  }]);
  const s = function(t2) {
    if (0 === t2.length)
      return;
    return fn(te.create(
      t2,
      "and"
      /* CompositeOperator.AND */
    ));
  }(e.filters);
  s && (n.structuredQuery.where = s);
  const i = function(t2) {
    if (0 === t2.length)
      return;
    return t2.map((t3) => (
      // visible for testing
      function(t4) {
        return {
          field: ln(t4.field),
          direction: cn(t4.dir)
        };
      }(t3)
    ));
  }(e.orderBy);
  i && (n.structuredQuery.orderBy = i);
  const o = function(t2, e2) {
    return t2.L || ft(e2) ? e2 : {
      value: e2
    };
  }(t, e.limit);
  var u;
  return null !== o && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t2) {
    return {
      before: !t2.inclusive,
      values: t2.position
    };
  }(e.endAt)), n;
}
function cn(t) {
  return ze[t];
}
function an(t) {
  return Qe[t];
}
function hn(t) {
  return We[t];
}
function ln(t) {
  return {
    fieldPath: t.canonicalString()
  };
}
function fn(t) {
  return t instanceof Xt ? function(t2) {
    if ("==" === t2.op) {
      if (Gt(t2.value))
        return {
          unaryFilter: {
            field: ln(t2.field),
            op: "IS_NAN"
          }
        };
      if (Wt(t2.value))
        return {
          unaryFilter: {
            field: ln(t2.field),
            op: "IS_NULL"
          }
        };
    } else if ("!=" === t2.op) {
      if (Gt(t2.value))
        return {
          unaryFilter: {
            field: ln(t2.field),
            op: "IS_NOT_NAN"
          }
        };
      if (Wt(t2.value))
        return {
          unaryFilter: {
            field: ln(t2.field),
            op: "IS_NOT_NULL"
          }
        };
    }
    return {
      fieldFilter: {
        field: ln(t2.field),
        op: an(t2.op),
        value: t2.value
      }
    };
  }(t) : t instanceof te ? function(t2) {
    const e = t2.getFilters().map((t3) => fn(t3));
    if (1 === e.length)
      return e[0];
    return {
      compositeFilter: {
        op: hn(t2.op),
        filters: e
      }
    };
  }(t) : b();
}
function dn(t) {
  const e = [];
  return t.fields.forEach((t2) => e.push(t2.canonicalString())), {
    fieldPaths: e
  };
}
function wn(t) {
  return t.length >= 4 && "projects" === t.get(0) && "databases" === t.get(2);
}
function mn(t) {
  return new Ge(
    t,
    /* useProto3Json= */
    true
  );
}
var pn = class {
  constructor(t, e, n = 1e3, r = 1.5, s = 6e4) {
    this.j = t, this.timerId = e, this.B = n, this.W = r, this.G = s, this.K = 0, this.Y = null, /** The last backoff attempt, as epoch milliseconds. */
    this.H = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.K = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  Z() {
    this.K = this.G;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  J(t) {
    this.cancel();
    const e = Math.floor(this.K + this.X()), n = Math.max(0, Date.now() - this.H), r = Math.max(0, e - n);
    r > 0 && y("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.K} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Y = this.j.enqueueAfterDelay(this.timerId, r, () => (this.H = Date.now(), t())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.K *= this.W, this.K < this.B && (this.K = this.B), this.K > this.G && (this.K = this.G);
  }
  tt() {
    null !== this.Y && (this.Y.skipDelay(), this.Y = null);
  }
  cancel() {
    null !== this.Y && (this.Y.cancel(), this.Y = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  X() {
    return (Math.random() - 0.5) * this.K;
  }
};
var yn = class extends class {
} {
  constructor(t, e, n, r) {
    super(), this.authCredentials = t, this.appCheckCredentials = e, this.connection = n, this.M = r, this.et = false;
  }
  nt() {
    if (this.et)
      throw new U(S, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  A(t, e, n) {
    return this.nt(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([r, s]) => this.connection.A(t, e, n, r, s)).catch((t2) => {
      throw "FirebaseError" === t2.name ? (t2.code === F && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t2) : new U(R, t2.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  P(t, e, n, r) {
    return this.nt(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.connection.P(t, e, n, s, i, r)).catch((t2) => {
      throw "FirebaseError" === t2.name ? (t2.code === F && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t2) : new U(R, t2.toString());
    });
  }
  terminate() {
    this.et = true;
  }
};
async function gn(t, e) {
  const n = A(t), r = nn(n.M) + "/documents", s = {
    writes: e.map((t2) => on(n.M, t2))
  };
  await n.A("Commit", r, s);
}
async function _n(t, e) {
  const n = A(t), r = nn(n.M) + "/documents", s = {
    documents: e.map((t2) => Xe(n.M, t2))
  }, i = await n.P("BatchGetDocuments", r, s, e.length), o = /* @__PURE__ */ new Map();
  i.forEach((t2) => {
    const e2 = sn(n.M, t2);
    o.set(e2.key.toString(), e2);
  });
  const u = [];
  return e.forEach((t2) => {
    const e2 = o.get(t2.toString());
    E(!!e2), u.push(e2);
  }), u;
}
async function vn(t, e) {
  const n = A(t), r = un(n.M, Ve(e));
  return (await n.P("RunQuery", r.parent, {
    structuredQuery: r.structuredQuery
  })).filter((t2) => !!t2.document).map((t2) => function(t3, e2, n2) {
    const r2 = tn(t3, e2.name), s = Ze(e2.updateTime), i = e2.createTime ? Ze(e2.createTime) : fe.min(), o = new _e({
      mapValue: {
        fields: e2.fields
      }
    }), u = ve.newFoundDocument(r2, s, i, o);
    return n2 && u.setHasCommittedMutations(), n2 ? u.setHasCommittedMutations() : u;
  }(n.M, t2.document, void 0));
}
async function bn(t, e, n) {
  const r = A(t), s = function(t2, e2, n2) {
    const r2 = un(t2, e2), s2 = [];
    return n2.forEach((t3) => {
      "count" === t3.N ? s2.push({
        alias: t3.alias.canonicalString(),
        count: {}
      }) : "avg" === t3.N ? s2.push({
        alias: t3.alias.canonicalString(),
        avg: {
          field: ln(t3.fieldPath)
        }
      }) : "sum" === t3.N && s2.push({
        alias: t3.alias.canonicalString(),
        sum: {
          field: ln(t3.fieldPath)
        }
      });
    }), {
      structuredAggregationQuery: {
        aggregations: s2,
        structuredQuery: r2.structuredQuery
      },
      parent: r2.parent
    };
  }(r.M, Ve(e), n), i = s.parent;
  r.connection.v || delete s.parent;
  const o = (await r.P(
    "RunAggregationQuery",
    i,
    s,
    /*expectedResponseCount=*/
    1
  )).filter((t2) => !!t2.result);
  return E(1 === o.length), (u = o[0]).result, u.result.aggregateFields, new _e({
    mapValue: {
      fields: null === (c = u.result) || void 0 === c ? void 0 : c.aggregateFields
    }
  });
  var u, c;
}
var En = /* @__PURE__ */ new Map();
function An(t) {
  if (t._terminated)
    throw new U(S, "The client has already been terminated.");
  if (!En.has(t)) {
    y("ComponentProvider", "Initializing Datastore");
    const i = function(t2) {
      return new gt(t2, fetch.bind(null));
    }((e = t._databaseId, n = t.app.options.appId || "", r = t._persistenceKey, s = t._freezeSettings(), new Z(e, n, r, s.host, s.ssl, s.experimentalForceLongPolling, s.experimentalAutoDetectLongPolling, s.useFetchStreams))), o = mn(t._databaseId), u = function(t2, e2, n2, r2) {
      return new yn(t2, e2, n2, r2);
    }(t._authCredentials, t._appCheckCredentials, i, o);
    En.set(t, u);
  }
  var e, n, r, s;
  return En.get(t);
}
var In = class {
  constructor(t) {
    var e;
    if (void 0 === t.host) {
      if (void 0 !== t.ssl)
        throw new U(P, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t.host, this.ssl = null === (e = t.ssl) || void 0 === e || e;
    if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, void 0 === t.cacheSizeBytes)
      this.cacheSizeBytes = 41943040;
    else {
      if (-1 !== t.cacheSizeBytes && t.cacheSizeBytes < 1048576)
        throw new U(P, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t.useFetchStreams, function(t2, e2, n, r) {
      if (true === e2 && true === r)
        throw new U(P, `${t2} and ${n} cannot be used together.`);
    }("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling);
  }
  isEqual(t) {
    return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams;
  }
};
var Tn = class {
  /** @hideconstructor */
  constructor(t, e, n, r) {
    this._authCredentials = t, this._appCheckCredentials = e, this._databaseId = n, this._app = r, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new In({}), this._settingsFrozen = false;
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app)
      throw new U(S, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return void 0 !== this._terminateTask;
  }
  _setSettings(t) {
    if (this._settingsFrozen)
      throw new U(S, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new In(t), void 0 !== t.credentials && (this._authCredentials = function(t2) {
      if (!t2)
        return new z();
      switch (t2.type) {
        case "gapi":
          const e = t2.client;
          return new K(e, t2.sessionIndex || "0", t2.iamToken || null, t2.authTokenFactory || null);
        case "provider":
          return t2.client;
        default:
          throw new U(P, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(t) {
      const e = En.get(t);
      e && (y("ComponentProvider", "Removing Datastore"), En.delete(t), e.terminate());
    }(this), Promise.resolve();
  }
};
function Rn(t, e, n) {
  n || (n = "(default)");
  const r = _getProvider(t, "firestore/lite");
  if (r.isInitialized(n))
    throw new U(S, "Firestore can only be initialized once per app.");
  return r.initialize({
    options: e,
    instanceIdentifier: n
  });
}
function Pn(e, n) {
  const r = "object" == typeof e ? e : getApp(), s = "string" == typeof e ? e : n || "(default)", i = _getProvider(r, "firestore/lite").getImmediate({
    identifier: s
  });
  if (!i._initialized) {
    const t = getDefaultEmulatorHostnameAndPort("firestore");
    t && Vn(i, ...t);
  }
  return i;
}
function Vn(t, e, n, r = {}) {
  var s;
  const i = (t = ct(t, Tn))._getSettings();
  if ("firestore.googleapis.com" !== i.host && i.host !== e && _("Host has been set in both settings() and useEmulator(), emulator host will be used"), t._setSettings(Object.assign(Object.assign({}, i), {
    host: `${e}:${n}`,
    ssl: false
  })), r.mockUserToken) {
    let e2, n2;
    if ("string" == typeof r.mockUserToken)
      e2 = r.mockUserToken, n2 = d.MOCK_USER;
    else {
      e2 = createMockUserToken(r.mockUserToken, null === (s = t._app) || void 0 === s ? void 0 : s.options.projectId);
      const i2 = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!i2)
        throw new U(P, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new d(i2);
    }
    t._authCredentials = new Q(new B(e2, n2));
  }
}
function $n(t) {
  return t = ct(t, Tn), _removeServiceInstance(t.app, "firestore/lite"), t._delete();
}
var Dn = class {
  /**
   * Create a new AggregateField<T>
   * @param _aggregateType Specifies the type of aggregation operation to perform.
   * @param _internalFieldPath Optionally specifies the field that is aggregated.
   * @internal
   */
  constructor(t = "count", e) {
    this._aggregateType = t, this._internalFieldPath = e, /** A type string to uniquely identify instances of this class. */
    this.type = "AggregateField";
  }
};
var Nn = class {
  /** @hideconstructor */
  constructor(t, e, n) {
    this._userDataWriter = e, this._data = n, /** A type string to uniquely identify instances of this class. */
    this.type = "AggregateQuerySnapshot", this.query = t;
  }
  /**
   * Returns the results of the aggregations performed over the underlying
   * query.
   *
   * The keys of the returned object will be the same as those of the
   * `AggregateSpec` object specified to the aggregation method, and the values
   * will be the corresponding aggregation result.
   *
   * @returns The results of the aggregations performed over the underlying
   * query.
   */
  data() {
    return this._userDataWriter.convertValue(this._data.value);
  }
};
var Fn = class _Fn {
  /** @hideconstructor */
  constructor(t, e, n) {
    this.converter = e, this._key = n, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = t;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new Sn(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t) {
    return new _Fn(this.firestore, t, this._key);
  }
};
var xn = class _xn {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(t, e, n) {
    this.converter = e, this._query = n, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = t;
  }
  withConverter(t) {
    return new _xn(this.firestore, t, this._query);
  }
};
var Sn = class _Sn extends xn {
  /** @hideconstructor */
  constructor(t, e, n) {
    super(t, e, new Ae(n)), this._path = n, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const t = this._path.popLast();
    return t.isEmpty() ? null : new Fn(
      this.firestore,
      /* converter= */
      null,
      new rt(t)
    );
  }
  withConverter(t) {
    return new _Sn(this.firestore, t, this._path);
  }
};
function qn(t, e, ...n) {
  if (t = getModularInstance(t), st("collection", "path", e), t instanceof Tn) {
    const r = tt.fromString(e, ...n);
    return ot(r), new Sn(
      t,
      /* converter= */
      null,
      r
    );
  }
  {
    if (!(t instanceof Fn || t instanceof Sn))
      throw new U(P, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = t._path.child(tt.fromString(e, ...n));
    return ot(r), new Sn(
      t.firestore,
      /* converter= */
      null,
      r
    );
  }
}
function On(t, e) {
  if (t = ct(t, Tn), st("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new U(P, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new xn(
    t,
    /* converter= */
    null,
    function(t2) {
      return new Ae(tt.emptyPath(), t2);
    }(e)
  );
}
function kn(t, e, ...n) {
  if (t = getModularInstance(t), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  1 === arguments.length && (e = At.F()), st("doc", "path", e), t instanceof Tn) {
    const r = tt.fromString(e, ...n);
    return it(r), new Fn(
      t,
      /* converter= */
      null,
      new rt(r)
    );
  }
  {
    if (!(t instanceof Fn || t instanceof Sn))
      throw new U(P, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = t._path.child(tt.fromString(e, ...n));
    return it(r), new Fn(t.firestore, t instanceof Sn ? t.converter : null, new rt(r));
  }
}
function Cn(t, e) {
  return t = getModularInstance(t), e = getModularInstance(e), (t instanceof Fn || t instanceof Sn) && (e instanceof Fn || e instanceof Sn) && (t.firestore === e.firestore && t.path === e.path && t.converter === e.converter);
}
function Ln(t, e) {
  return t = getModularInstance(t), e = getModularInstance(e), t instanceof xn && e instanceof xn && (t.firestore === e.firestore && De(t._query, e._query) && t.converter === e.converter);
}
var Mn = class _Mn {
  /** @hideconstructor */
  constructor(t) {
    this._byteString = t;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(t) {
    try {
      return new _Mn($t.fromBase64String(t));
    } catch (t2) {
      throw new U(P, "Failed to construct data from Base64 string: " + t2);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(t) {
    return new _Mn($t.fromUint8Array(t));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(t) {
    return this._byteString.isEqual(t._byteString);
  }
};
var Un = class {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...t) {
    for (let e = 0; e < t.length; ++e)
      if (0 === t[e].length)
        throw new U(P, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new nt(t);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(t) {
    return this._internalPath.isEqual(t._internalPath);
  }
};
function jn() {
  return new Un("__name__");
}
var Bn = class {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(t) {
    this._methodName = t;
  }
};
var zn = class {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(t, e) {
    if (!isFinite(t) || t < -90 || t > 90)
      throw new U(P, "Latitude must be a number between -90 and 90, but was: " + t);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new U(P, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t, this._long = e;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(t) {
    return this._lat === t._lat && this._long === t._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(t) {
    return It(this._lat, t._lat) || It(this._long, t._long);
  }
};
var Qn = /^__.*__$/;
var Wn = class {
  constructor(t, e, n) {
    this.data = t, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t, e) {
    return null !== this.fieldMask ? new Ue(t, this.data, this.fieldMask, e, this.fieldTransforms) : new Me(t, this.data, e, this.fieldTransforms);
  }
};
var Gn = class {
  constructor(t, e, n) {
    this.data = t, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t, e) {
    return new Ue(t, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function Kn(t) {
  switch (t) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw b();
  }
}
var Yn = class _Yn {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(t, e, n, r, s, i) {
    this.settings = t, this.databaseId = e, this.M = n, this.ignoreUndefinedProperties = r, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    void 0 === s && this.rt(), this.fieldTransforms = s || [], this.fieldMask = i || [];
  }
  get path() {
    return this.settings.path;
  }
  get st() {
    return this.settings.st;
  }
  /** Returns a new context with the specified settings overwritten. */
  it(t) {
    return new _Yn(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.M, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  ot(t) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t), r = this.it({
      path: n,
      ut: false
    });
    return r.ct(t), r;
  }
  at(t) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t), r = this.it({
      path: n,
      ut: false
    });
    return r.rt(), r;
  }
  ht(t) {
    return this.it({
      path: void 0,
      ut: true
    });
  }
  lt(t) {
    return mr(t, this.settings.methodName, this.settings.ft || false, this.path, this.settings.dt);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(t) {
    return void 0 !== this.fieldMask.find((e) => t.isPrefixOf(e)) || void 0 !== this.fieldTransforms.find((e) => t.isPrefixOf(e.field));
  }
  rt() {
    if (this.path)
      for (let t = 0; t < this.path.length; t++)
        this.ct(this.path.get(t));
  }
  ct(t) {
    if (0 === t.length)
      throw this.lt("Document fields must not be empty");
    if (Kn(this.st) && Qn.test(t))
      throw this.lt('Document fields cannot begin and end with "__"');
  }
};
var Hn = class {
  constructor(t, e, n) {
    this.databaseId = t, this.ignoreUndefinedProperties = e, this.M = n || mn(t);
  }
  /** Creates a new top-level parse context. */
  wt(t, e, n, r = false) {
    return new Yn({
      st: t,
      methodName: e,
      dt: n,
      path: nt.emptyPath(),
      ut: false,
      ft: r
    }, this.databaseId, this.M, this.ignoreUndefinedProperties);
  }
};
function Zn(t) {
  const e = t._freezeSettings(), n = mn(t._databaseId);
  return new Hn(t._databaseId, !!e.ignoreUndefinedProperties, n);
}
function Jn(t, e, n, r, s, i = {}) {
  const o = t.wt(i.merge || i.mergeFields ? 2 : 0, e, n, s);
  lr("Data must be an object, but it was:", o, r);
  const u = ar(r, o);
  let c, a;
  if (i.merge)
    c = new ge(o.fieldMask), a = o.fieldTransforms;
  else if (i.mergeFields) {
    const t2 = [];
    for (const r2 of i.mergeFields) {
      const s2 = fr(e, r2, n);
      if (!o.contains(s2))
        throw new U(P, `Field '${s2}' is specified in your field mask but missing from your input data.`);
      pr(t2, s2) || t2.push(s2);
    }
    c = new ge(t2), a = o.fieldTransforms.filter((t3) => c.covers(t3.field));
  } else
    c = null, a = o.fieldTransforms;
  return new Wn(new _e(u), c, a);
}
var Xn = class _Xn extends Bn {
  _toFieldTransform(t) {
    if (2 !== t.st)
      throw 1 === t.st ? t.lt(`${this._methodName}() can only appear at the top level of your update data`) : t.lt(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t.fieldMask.push(t.path), null;
  }
  isEqual(t) {
    return t instanceof _Xn;
  }
};
function tr(t, e, n) {
  return new Yn({
    st: 3,
    dt: e.settings.dt,
    methodName: t._methodName,
    ut: n
  }, e.databaseId, e.M, e.ignoreUndefinedProperties);
}
var er = class _er extends Bn {
  _toFieldTransform(t) {
    return new ke(t.path, new xe());
  }
  isEqual(t) {
    return t instanceof _er;
  }
};
var nr = class extends Bn {
  constructor(t, e) {
    super(t), this.yt = e;
  }
  _toFieldTransform(t) {
    const e = tr(
      this,
      t,
      /*array=*/
      true
    ), n = this.yt.map((t2) => cr(t2, e)), r = new Se(n);
    return new ke(t.path, r);
  }
  isEqual(t) {
    return this === t;
  }
};
var rr = class extends Bn {
  constructor(t, e) {
    super(t), this.yt = e;
  }
  _toFieldTransform(t) {
    const e = tr(
      this,
      t,
      /*array=*/
      true
    ), n = this.yt.map((t2) => cr(t2, e)), r = new qe(n);
    return new ke(t.path, r);
  }
  isEqual(t) {
    return this === t;
  }
};
var sr = class extends Bn {
  constructor(t, e) {
    super(t), this.gt = e;
  }
  _toFieldTransform(t) {
    const e = new Oe(t.M, Ne(t.M, this.gt));
    return new ke(t.path, e);
  }
  isEqual(t) {
    return this === t;
  }
};
function ir(t, e, n, r) {
  const s = t.wt(1, e, n);
  lr("Data must be an object, but it was:", s, r);
  const i = [], o = _e.empty();
  Pt(r, (t2, r2) => {
    const u2 = wr(e, t2, n);
    r2 = getModularInstance(r2);
    const c = s.at(u2);
    if (r2 instanceof Xn)
      i.push(u2);
    else {
      const t3 = cr(r2, c);
      null != t3 && (i.push(u2), o.set(u2, t3));
    }
  });
  const u = new ge(i);
  return new Gn(o, u, s.fieldTransforms);
}
function or(t, e, n, r, s, i) {
  const o = t.wt(1, e, n), u = [fr(e, r, n)], c = [s];
  if (i.length % 2 != 0)
    throw new U(P, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t2 = 0; t2 < i.length; t2 += 2)
    u.push(fr(e, i[t2])), c.push(i[t2 + 1]);
  const a = [], h = _e.empty();
  for (let t2 = u.length - 1; t2 >= 0; --t2)
    if (!pr(a, u[t2])) {
      const e2 = u[t2];
      let n2 = c[t2];
      n2 = getModularInstance(n2);
      const r2 = o.at(e2);
      if (n2 instanceof Xn)
        a.push(e2);
      else {
        const t3 = cr(n2, r2);
        null != t3 && (a.push(e2), h.set(e2, t3));
      }
    }
  const f = new ge(a);
  return new Gn(h, f, o.fieldTransforms);
}
function ur(t, e, n, r = false) {
  return cr(n, t.wt(r ? 4 : 3, e));
}
function cr(t, e) {
  if (hr(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    t = getModularInstance(t)
  ))
    return lr("Unsupported field value:", e, t), ar(t, e);
  if (t instanceof Bn)
    return function(t2, e2) {
      if (!Kn(e2.st))
        throw e2.lt(`${t2._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.lt(`${t2._methodName}() is not currently supported inside arrays`);
      const n = t2._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t, e), null;
  if (void 0 === t && e.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    e.path && e.fieldMask.push(e.path), t instanceof Array
  ) {
    if (e.settings.ut && 4 !== e.st)
      throw e.lt("Nested arrays are not supported");
    return function(t2, e2) {
      const n = [];
      let r = 0;
      for (const s of t2) {
        let t3 = cr(s, e2.ht(r));
        null == t3 && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (t3 = {
          nullValue: "NULL_VALUE"
        }), n.push(t3), r++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t, e);
  }
  return function(t2, e2) {
    if (null === (t2 = getModularInstance(t2)))
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t2)
      return Ne(e2.M, t2);
    if ("boolean" == typeof t2)
      return {
        booleanValue: t2
      };
    if ("string" == typeof t2)
      return {
        stringValue: t2
      };
    if (t2 instanceof Date) {
      const n = St.fromDate(t2);
      return {
        timestampValue: Ke(e2.M, n)
      };
    }
    if (t2 instanceof St) {
      const n = new St(t2.seconds, 1e3 * Math.floor(t2.nanoseconds / 1e3));
      return {
        timestampValue: Ke(e2.M, n)
      };
    }
    if (t2 instanceof zn)
      return {
        geoPointValue: {
          latitude: t2.latitude,
          longitude: t2.longitude
        }
      };
    if (t2 instanceof Mn)
      return {
        bytesValue: Ye(e2.M, t2._byteString)
      };
    if (t2 instanceof Fn) {
      const n = e2.databaseId, r = t2.firestore._databaseId;
      if (!r.isEqual(n))
        throw e2.lt(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: Je(t2.firestore._databaseId || e2.databaseId, t2._key.path)
      };
    }
    throw e2.lt(`Unsupported field value: ${ut(t2)}`);
  }(t, e);
}
function ar(t, e) {
  const n = {};
  return !function(t2) {
    for (const e2 in t2)
      if (Object.prototype.hasOwnProperty.call(t2, e2))
        return false;
    return true;
  }(t) ? Pt(t, (t2, r) => {
    const s = cr(r, e.ot(t2));
    null != s && (n[t2] = s);
  }) : (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    e.path && e.path.length > 0 && e.fieldMask.push(e.path)
  ), {
    mapValue: {
      fields: n
    }
  };
}
function hr(t) {
  return !("object" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof St || t instanceof zn || t instanceof Mn || t instanceof Fn || t instanceof Bn);
}
function lr(t, e, n) {
  if (!hr(n) || !function(t2) {
    return "object" == typeof t2 && null !== t2 && (Object.getPrototypeOf(t2) === Object.prototype || null === Object.getPrototypeOf(t2));
  }(n)) {
    const r = ut(n);
    throw "an object" === r ? e.lt(t + " a custom object") : e.lt(t + " " + r);
  }
}
function fr(t, e, n) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    (e = getModularInstance(e)) instanceof Un
  )
    return e._internalPath;
  if ("string" == typeof e)
    return wr(t, e);
  throw mr(
    "Field path arguments must be of type string or ",
    t,
    /* hasConverter= */
    false,
    /* path= */
    void 0,
    n
  );
}
var dr = new RegExp("[~\\*/\\[\\]]");
function wr(t, e, n) {
  if (e.search(dr) >= 0)
    throw mr(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      t,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n
    );
  try {
    return new Un(...e.split("."))._internalPath;
  } catch (r) {
    throw mr(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      t,
      /* hasConverter= */
      false,
      /* path= */
      void 0,
      n
    );
  }
}
function mr(t, e, n, r, s) {
  const i = r && !r.isEmpty(), o = void 0 !== s;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let c = "";
  return (i || o) && (c += " (found", i && (c += ` in field ${r}`), o && (c += ` in document ${s}`), c += ")"), new U(P, u + t + c);
}
function pr(t, e) {
  return t.some((t2) => t2.isEqual(e));
}
var yr = class {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(t, e, n, r, s) {
    this._firestore = t, this._userDataWriter = e, this._key = n, this._document = r, this._converter = s;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new Fn(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return null !== this._document;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const t = new gr(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(t);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(t) {
    if (this._document) {
      const e = this._document.data.field(br("DocumentSnapshot.get", t));
      if (null !== e)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var gr = class extends yr {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
};
var _r = class {
  /** @hideconstructor */
  constructor(t, e) {
    this._docs = e, this.query = t;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    return [...this._docs];
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this.docs.length;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return 0 === this.docs.length;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(t, e) {
    this._docs.forEach(t, e);
  }
};
function vr(t, e) {
  return t = getModularInstance(t), e = getModularInstance(e), t instanceof yr && e instanceof yr ? t._firestore === e._firestore && t._key.isEqual(e._key) && (null === t._document ? null === e._document : t._document.isEqual(e._document)) && t._converter === e._converter : t instanceof _r && e instanceof _r && (Ln(t.query, e.query) && Tt(t.docs, e.docs, vr));
}
function br(t, e) {
  return "string" == typeof e ? wr(t, e) : e instanceof Un ? e._internalPath : e._delegate._internalPath;
}
var Er = class {
};
var Ar = class extends Er {
};
function Ir(t, e, ...n) {
  let r = [];
  e instanceof Er && r.push(e), r = r.concat(n), function(t2) {
    const e2 = t2.filter((t3) => t3 instanceof Pr).length, n2 = t2.filter((t3) => t3 instanceof Tr).length;
    if (e2 > 1 || e2 > 0 && n2 > 0)
      throw new U(P, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(r);
  for (const e2 of r)
    t = e2._apply(t);
  return t;
}
var Tr = class _Tr extends Ar {
  /**
   * @internal
   */
  constructor(t, e, n) {
    super(), this._field = t, this._op = e, this._value = n, /** The type of this query constraint */
    this.type = "where";
  }
  static _create(t, e, n) {
    return new _Tr(t, e, n);
  }
  _apply(t) {
    const e = this._parse(t);
    return zr(t._query, e), new xn(t.firestore, t.converter, $e(t._query, e));
  }
  _parse(t) {
    const e = Zn(t.firestore), n = function(t2, e2, n2, r, s, i, o) {
      let u;
      if (s.isKeyField()) {
        if ("array-contains" === i || "array-contains-any" === i)
          throw new U(P, `Invalid Query. You can't perform '${i}' queries on documentId().`);
        if ("in" === i || "not-in" === i) {
          Br(o, i);
          const e3 = [];
          for (const n3 of o)
            e3.push(jr(r, t2, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = jr(r, t2, o);
      } else
        "in" !== i && "not-in" !== i && "array-contains-any" !== i || Br(o, i), u = ur(
          n2,
          e2,
          o,
          /* allowArrays= */
          "in" === i || "not-in" === i
        );
      return Xt.create(s, i, u);
    }(t._query, "where", e, t.firestore._databaseId, this._field, this._op, this._value);
    return n;
  }
};
function Rr(t, e, n) {
  const r = e, s = br("where", t);
  return Tr._create(s, r, n);
}
var Pr = class _Pr extends Er {
  /**
   * @internal
   */
  constructor(t, e) {
    super(), this.type = t, this._queryConstraints = e;
  }
  static _create(t, e) {
    return new _Pr(t, e);
  }
  _parse(t) {
    const e = this._queryConstraints.map((e2) => e2._parse(t)).filter((t2) => t2.getFilters().length > 0);
    return 1 === e.length ? e[0] : te.create(e, this._getOperator());
  }
  _apply(t) {
    const e = this._parse(t);
    return 0 === e.getFilters().length ? t : (function(t2, e2) {
      let n = t2;
      const r = e2.getFlattenedFilters();
      for (const t3 of r)
        zr(n, t3), n = $e(n, t3);
    }(t._query, e), new xn(t.firestore, t.converter, $e(t._query, e)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return "and" === this.type ? "and" : "or";
  }
};
function Vr(...t) {
  return t.forEach((t2) => Wr("or", t2)), Pr._create("or", t);
}
function $r(...t) {
  return t.forEach((t2) => Wr("and", t2)), Pr._create("and", t);
}
var Dr = class _Dr extends Ar {
  /**
   * @internal
   */
  constructor(t, e) {
    super(), this._field = t, this._direction = e, /** The type of this query constraint */
    this.type = "orderBy";
  }
  static _create(t, e) {
    return new _Dr(t, e);
  }
  _apply(t) {
    const e = function(t2, e2, n) {
      if (null !== t2.startAt)
        throw new U(P, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (null !== t2.endAt)
        throw new U(P, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const r = new he(e2, n);
      return function(t3, e3) {
        if (null === Ie(t3)) {
          const n2 = Te(t3);
          null !== n2 && Qr(t3, n2, e3.field);
        }
      }(t2, r), r;
    }(t._query, this._field, this._direction);
    return new xn(t.firestore, t.converter, function(t2, e2) {
      const n = t2.explicitOrderBy.concat([e2]);
      return new Ae(t2.path, t2.collectionGroup, n, t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, t2.endAt);
    }(t._query, e));
  }
};
function Nr(t, e = "asc") {
  const n = e, r = br("orderBy", t);
  return Dr._create(r, n);
}
var Fr = class _Fr extends Ar {
  /**
   * @internal
   */
  constructor(t, e, n) {
    super(), this.type = t, this._limit = e, this._limitType = n;
  }
  static _create(t, e, n) {
    return new _Fr(t, e, n);
  }
  _apply(t) {
    return new xn(t.firestore, t.converter, function(t2, e, n) {
      return new Ae(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
    }(t._query, this._limit, this._limitType));
  }
};
function xr(t) {
  return at("limit", t), Fr._create(
    "limit",
    t,
    "F"
    /* LimitType.First */
  );
}
function Sr(t) {
  return at("limitToLast", t), Fr._create(
    "limitToLast",
    t,
    "L"
    /* LimitType.Last */
  );
}
var qr = class _qr extends Ar {
  /**
   * @internal
   */
  constructor(t, e, n) {
    super(), this.type = t, this._docOrFields = e, this._inclusive = n;
  }
  static _create(t, e, n) {
    return new _qr(t, e, n);
  }
  _apply(t) {
    const e = Ur(t, this.type, this._docOrFields, this._inclusive);
    return new xn(t.firestore, t.converter, function(t2, e2) {
      return new Ae(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, e2, t2.endAt);
    }(t._query, e));
  }
};
function Or(...t) {
  return qr._create(
    "startAt",
    t,
    /*inclusive=*/
    true
  );
}
function kr(...t) {
  return qr._create(
    "startAfter",
    t,
    /*inclusive=*/
    false
  );
}
var Cr = class _Cr extends Ar {
  /**
   * @internal
   */
  constructor(t, e, n) {
    super(), this.type = t, this._docOrFields = e, this._inclusive = n;
  }
  static _create(t, e, n) {
    return new _Cr(t, e, n);
  }
  _apply(t) {
    const e = Ur(t, this.type, this._docOrFields, this._inclusive);
    return new xn(t.firestore, t.converter, function(t2, e2) {
      return new Ae(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, e2);
    }(t._query, e));
  }
};
function Lr(...t) {
  return Cr._create(
    "endBefore",
    t,
    /*inclusive=*/
    false
  );
}
function Mr(...t) {
  return Cr._create(
    "endAt",
    t,
    /*inclusive=*/
    true
  );
}
function Ur(t, e, n, r) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof yr)
    return function(t2, e2, n2, r2, s) {
      if (!r2)
        throw new U($, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const i = [];
      for (const n3 of Pe(t2))
        if (n3.field.isKeyField())
          i.push(zt(e2, r2.key));
        else {
          const t3 = r2.data.field(n3.field);
          if (qt(t3))
            throw new U(P, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (null === t3) {
            const t4 = n3.field.canonicalString();
            throw new U(P, `Invalid query. You are trying to start or end a query using a document for which the field '${t4}' (used as the orderBy) does not exist.`);
          }
          i.push(t3);
        }
      return new Ht(i, s);
    }(t._query, t.firestore._databaseId, e, n[0]._document, r);
  {
    const s = Zn(t.firestore);
    return function(t2, e2, n2, r2, s2, i) {
      const o = t2.explicitOrderBy;
      if (s2.length > o.length)
        throw new U(P, `Too many arguments provided to ${r2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let i2 = 0; i2 < s2.length; i2++) {
        const c = s2[i2];
        if (o[i2].field.isKeyField()) {
          if ("string" != typeof c)
            throw new U(P, `Invalid query. Expected a string for document ID in ${r2}(), but got a ${typeof c}`);
          if (!Re(t2) && -1 !== c.indexOf("/"))
            throw new U(P, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${r2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t2.path.child(tt.fromString(c));
          if (!rt.isDocumentKey(n3))
            throw new U(P, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${r2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const s3 = new rt(n3);
          u.push(zt(e2, s3));
        } else {
          const t3 = ur(n2, r2, c);
          u.push(t3);
        }
      }
      return new Ht(u, i);
    }(t._query, t.firestore._databaseId, s, e, n, r);
  }
}
function jr(t, e, n) {
  if ("string" == typeof (n = getModularInstance(n))) {
    if ("" === n)
      throw new U(P, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Re(e) && -1 !== n.indexOf("/"))
      throw new U(P, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const r = e.path.child(tt.fromString(n));
    if (!rt.isDocumentKey(r))
      throw new U(P, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
    return zt(t, new rt(r));
  }
  if (n instanceof Fn)
    return zt(t, n._key);
  throw new U(P, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${ut(n)}.`);
}
function Br(t, e) {
  if (!Array.isArray(t) || 0 === t.length)
    throw new U(P, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function zr(t, e) {
  if (e.isInequality()) {
    const n2 = Te(t), r = e.field;
    if (null !== n2 && !n2.isEqual(r))
      throw new U(P, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n2.toString()}' and '${r.toString()}'`);
    const s = Ie(t);
    null !== s && Qr(t, r, s);
  }
  const n = function(t2, e2) {
    for (const n2 of t2)
      for (const t3 of n2.getFlattenedFilters())
        if (e2.indexOf(t3.op) >= 0)
          return t3.op;
    return null;
  }(t.filters, function(t2) {
    switch (t2) {
      case "!=":
        return [
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "array-contains-any":
      case "in":
        return [
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "not-in":
        return [
          "array-contains-any",
          "in",
          "not-in",
          "!="
          /* Operator.NOT_EQUAL */
        ];
      default:
        return [];
    }
  }(e.op));
  if (null !== n)
    throw n === e.op ? new U(P, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new U(P, `Invalid query. You cannot use '${e.op.toString()}' filters with '${n.toString()}' filters.`);
}
function Qr(t, e, n) {
  if (!n.isEqual(e))
    throw new U(P, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
function Wr(t, e) {
  if (!(e instanceof Tr || e instanceof Pr))
    throw new U(P, `Function ${t}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);
}
function Gr(t, e, n) {
  let r;
  return r = t ? n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e) : e, r;
}
var Kr = class extends class {
  convertValue(t, e = "none") {
    switch (Lt(t)) {
      case 0:
        return null;
      case 1:
        return t.booleanValue;
      case 2:
        return Ft(t.integerValue || t.doubleValue);
      case 3:
        return this.convertTimestamp(t.timestampValue);
      case 4:
        return this.convertServerTimestamp(t, e);
      case 5:
        return t.stringValue;
      case 6:
        return this.convertBytes(xt(t.bytesValue));
      case 7:
        return this.convertReference(t.referenceValue);
      case 8:
        return this.convertGeoPoint(t.geoPointValue);
      case 9:
        return this.convertArray(t.arrayValue, e);
      case 10:
        return this.convertObject(t.mapValue, e);
      default:
        throw b();
    }
  }
  convertObject(t, e) {
    const n = {};
    return Pt(t.fields, (t2, r) => {
      n[t2] = this.convertValue(r, e);
    }), n;
  }
  convertGeoPoint(t) {
    return new zn(Ft(t.latitude), Ft(t.longitude));
  }
  convertArray(t, e) {
    return (t.values || []).map((t2) => this.convertValue(t2, e));
  }
  convertServerTimestamp(t, e) {
    switch (e) {
      case "previous":
        const n = Ot(t);
        return null == n ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(kt(t));
      default:
        return null;
    }
  }
  convertTimestamp(t) {
    const e = Nt(t);
    return new St(e.seconds, e.nanos);
  }
  convertDocumentKey(t, e) {
    const n = tt.fromString(t);
    E(wn(n));
    const r = new J(n.get(1), n.get(3)), s = new rt(n.popFirst(5));
    return r.isEqual(e) || // TODO(b/64130202): Somehow support foreign references.
    g(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), s;
  }
} {
  constructor(t) {
    super(), this.firestore = t;
  }
  convertBytes(t) {
    return new Mn(t);
  }
  convertReference(t) {
    const e = this.convertDocumentKey(t, this.firestore._databaseId);
    return new Fn(
      this.firestore,
      /* converter= */
      null,
      e
    );
  }
};
function Yr(t) {
  const e = An((t = ct(t, Fn)).firestore), n = new Kr(t.firestore);
  return _n(e, [t._key]).then((e2) => {
    E(1 === e2.length);
    const r = e2[0];
    return new yr(t.firestore, n, t._key, r.isFoundDocument() ? r : null, t.converter);
  });
}
function Hr(t) {
  !function(t2) {
    if ("L" === t2.limitType && 0 === t2.explicitOrderBy.length)
      throw new U(k, "limitToLast() queries require specifying at least one orderBy() clause");
  }((t = ct(t, xn))._query);
  const e = An(t.firestore), n = new Kr(t.firestore);
  return vn(e, t._query).then((e2) => {
    const r = e2.map((e3) => new gr(t.firestore, n, e3.key, e3, t.converter));
    return "L" === t._query.limitType && // Limit to last queries reverse the orderBy constraint that was
    // specified by the user. As such, we need to reverse the order of the
    // results to return the documents in the expected order.
    r.reverse(), new _r(t, r);
  });
}
function Zr(t, e, n) {
  const r = Gr((t = ct(t, Fn)).converter, e, n), s = Jn(Zn(t.firestore), "setDoc", t._key, r, null !== t.converter, n);
  return gn(An(t.firestore), [s.toMutation(t._key, Ce.none())]);
}
function Jr(t, e, n, ...r) {
  const s = Zn((t = ct(t, Fn)).firestore);
  let i;
  i = "string" == typeof (e = getModularInstance(e)) || e instanceof Un ? or(s, "updateDoc", t._key, e, n, r) : ir(s, "updateDoc", t._key, e);
  return gn(An(t.firestore), [i.toMutation(t._key, Ce.exists(true))]);
}
function Xr(t) {
  return gn(An((t = ct(t, Fn)).firestore), [new je(t._key, Ce.none())]);
}
function ts(t, e) {
  const n = kn(t = ct(t, Sn)), r = Gr(t.converter, e), s = Jn(Zn(t.firestore), "addDoc", n._key, r, null !== n.converter, {});
  return gn(An(t.firestore), [s.toMutation(n._key, Ce.exists(false))]).then(() => n);
}
function es(t) {
  return ns(t, {
    count: is()
  });
}
function ns(t, e) {
  const n = ct(t.firestore, Tn), r = An(n), s = function(t2, e2) {
    const n2 = [];
    for (const r2 in t2)
      Object.prototype.hasOwnProperty.call(t2, r2) && n2.push(e2(t2[r2], r2, t2));
    return n2;
  }(e, (t2, e2) => new bt(new vt(e2), t2._aggregateType, t2._internalFieldPath));
  return bn(r, t._query, s).then((e2) => function(t2, e3, n2) {
    const r2 = new Kr(t2);
    return new Nn(e3, r2, n2);
  }(n, t, e2));
}
function rs(t) {
  return new Dn("sum", fr("sum", t));
}
function ss(t) {
  return new Dn("avg", fr("average", t));
}
function is() {
  return new Dn("count");
}
function os(t, e) {
  var n, r;
  return t instanceof Dn && e instanceof Dn && t._aggregateType === e._aggregateType && (null === (n = t._internalFieldPath) || void 0 === n ? void 0 : n.canonicalString()) === (null === (r = e._internalFieldPath) || void 0 === r ? void 0 : r.canonicalString());
}
function us(t, e) {
  return Ln(t.query, e.query) && deepEqual(t.data(), e.data());
}
function cs() {
  return new Xn("deleteField");
}
function as() {
  return new er("serverTimestamp");
}
function hs(...t) {
  return new nr("arrayUnion", t);
}
function ls(...t) {
  return new rr("arrayRemove", t);
}
function fs(t) {
  return new sr("increment", t);
}
var ds = class {
  /** @hideconstructor */
  constructor(t, e) {
    this._firestore = t, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = Zn(t);
  }
  set(t, e, n) {
    this._verifyNotCommitted();
    const r = ws(t, this._firestore), s = Gr(r.converter, e, n), i = Jn(this._dataReader, "WriteBatch.set", r._key, s, null !== r.converter, n);
    return this._mutations.push(i.toMutation(r._key, Ce.none())), this;
  }
  update(t, e, n, ...r) {
    this._verifyNotCommitted();
    const s = ws(t, this._firestore);
    let i;
    return i = "string" == typeof (e = getModularInstance(e)) || e instanceof Un ? or(this._dataReader, "WriteBatch.update", s._key, e, n, r) : ir(this._dataReader, "WriteBatch.update", s._key, e), this._mutations.push(i.toMutation(s._key, Ce.exists(true))), this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `WriteBatch` instance. Used for chaining method calls.
   */
  delete(t) {
    this._verifyNotCommitted();
    const e = ws(t, this._firestore);
    return this._mutations = this._mutations.concat(new je(e._key, Ce.none())), this;
  }
  /**
   * Commits all of the writes in this write batch as a single atomic unit.
   *
   * The result of these writes will only be reflected in document reads that
   * occur after the returned promise resolves. If the client is offline, the
   * write fails. If you would like to see local modifications or buffer writes
   * until the client is online, use the full Firestore SDK.
   *
   * @returns A `Promise` resolved once all of the writes in the batch have been
   * successfully written to the backend as an atomic unit (note that it won't
   * resolve while you're offline).
   */
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new U(S, "A write batch can no longer be used after commit() has been called.");
  }
};
function ws(t, e) {
  if ((t = getModularInstance(t)).firestore !== e)
    throw new U(P, "Provided document reference is from a different Firestore instance.");
  return t;
}
function ms(t) {
  const e = An(t = ct(t, Tn));
  return new ds(t, (t2) => gn(e, t2));
}
var ps = class {
  constructor(t) {
    this.datastore = t, // The version of each document that was read during this transaction.
    this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, /**
     * A deferred usage error that occurred previously in this transaction that
     * will cause the transaction to fail once it actually commits.
     */
    this.lastWriteError = null, /**
     * Set of documents that have been written in the transaction.
     *
     * When there's more than one write to the same key in a transaction, any
     * writes after the first are handled differently.
     */
    this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new U(P, "Firestore transactions require all reads to be executed before all writes.");
    const e = await _n(this.datastore, t);
    return e.forEach((t2) => this.recordVersion(t2)), e;
  }
  set(t, e) {
    this.write(e.toMutation(t, this.precondition(t))), this.writtenDocs.add(t.toString());
  }
  update(t, e) {
    try {
      this.write(e.toMutation(t, this.preconditionForUpdate(t)));
    } catch (t2) {
      this.lastWriteError = t2;
    }
    this.writtenDocs.add(t.toString());
  }
  delete(t) {
    this.write(new je(t, this.precondition(t))), this.writtenDocs.add(t.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t = this.readVersions;
    this.mutations.forEach((e) => {
      t.delete(e.key.toString());
    }), // For each document that was read but not written to, we want to perform
    // a `verify` operation.
    t.forEach((t2, e) => {
      const n = rt.fromPath(e);
      this.mutations.push(new Be(n, this.precondition(n)));
    }), await gn(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t) {
    let e;
    if (t.isFoundDocument())
      e = t.version;
    else {
      if (!t.isNoDocument())
        throw b();
      e = fe.min();
    }
    const n = this.readVersions.get(t.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new U(q, "Document version changed between two reads.");
    } else
      this.readVersions.set(t.key.toString(), e);
  }
  /**
   * Returns the version of this document when it was read in this transaction,
   * as a precondition, or no precondition if it was not read.
   */
  precondition(t) {
    const e = this.readVersions.get(t.toString());
    return !this.writtenDocs.has(t.toString()) && e ? e.isEqual(fe.min()) ? Ce.exists(false) : Ce.updateTime(e) : Ce.none();
  }
  /**
   * Returns the precondition for a document if the operation is an update.
   */
  preconditionForUpdate(t) {
    const e = this.readVersions.get(t.toString());
    if (!this.writtenDocs.has(t.toString()) && e) {
      if (e.isEqual(fe.min()))
        throw new U(P, "Can't update a document that doesn't exist.");
      return Ce.updateTime(e);
    }
    return Ce.exists(true);
  }
  write(t) {
    this.ensureCommitNotCalled(), this.mutations.push(t);
  }
  ensureCommitNotCalled() {
  }
};
var ys = {
  maxAttempts: 5
};
var gs = class {
  constructor(t, e, n, r, s) {
    this.asyncQueue = t, this.datastore = e, this.options = n, this.updateFunction = r, this.deferred = s, this._t = n.maxAttempts, this.vt = new pn(
      this.asyncQueue,
      "transaction_retry"
      /* TimerId.TransactionRetry */
    );
  }
  /** Runs the transaction and sets the result on deferred. */
  run() {
    this._t -= 1, this.bt();
  }
  bt() {
    this.vt.J(async () => {
      const t = new ps(this.datastore), e = this.Et(t);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t2) => {
          this.At(t2);
        }));
      }).catch((t2) => {
        this.At(t2);
      });
    });
  }
  Et(t) {
    try {
      const e = this.updateFunction(t);
      return !ft(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t2) {
      return this.deferred.reject(t2), null;
    }
  }
  At(t) {
    this._t > 0 && this.It(t) ? (this._t -= 1, this.asyncQueue.enqueueAndForget(() => (this.bt(), Promise.resolve()))) : this.deferred.reject(t);
  }
  It(t) {
    if ("FirebaseError" === t.name) {
      const e = t.code;
      return "aborted" === e || "failed-precondition" === e || "already-exists" === e || !/**
      * Determines whether an error code represents a permanent error when received
      * in response to a non-write operation.
      *
      * See isPermanentWriteError for classifying write errors.
      */
      function(t2) {
        switch (t2) {
          default:
            return b();
          case T:
          case R:
          case V:
          case x:
          case C:
          case L:
          case F:
            return false;
          case P:
          case $:
          case D:
          case N:
          case S:
          case q:
          case O:
          case k:
          case M:
            return true;
        }
      }(e);
    }
    return false;
  }
};
function _s() {
  return "undefined" != typeof document ? document : null;
}
var vs = class _vs {
  constructor(t, e, n, r, s) {
    this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = s, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((t2) => {
    });
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(t, e, n, r, s) {
    const i = Date.now() + n, o = new _vs(t, e, i, r, s);
    return o.start(n), o;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(t) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(t) {
    null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new U(T, "Operation cancelled" + (t ? ": " + t : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t) => this.deferred.resolve(t))) : Promise.resolve());
  }
  clearTimeout() {
    null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
var bs = class {
  constructor() {
    this.Tt = Promise.resolve(), // A list of retryable operations. Retryable operations are run in order and
    // retried with backoff.
    this.Rt = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.Pt = false, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.Vt = [], // visible for testing
    this.$t = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.Dt = false, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.Nt = false, // List of TimerIds to fast-forward delays for.
    this.Ft = [], // Backoff timer used to schedule retries for retryable operations
    this.vt = new pn(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this.xt = () => {
      const t2 = _s();
      t2 && y("AsyncQueue", "Visibility state changed to " + t2.visibilityState), this.vt.tt();
    };
    const t = _s();
    t && "function" == typeof t.addEventListener && t.addEventListener("visibilitychange", this.xt);
  }
  get isShuttingDown() {
    return this.Pt;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(t) {
    this.enqueue(t);
  }
  enqueueAndForgetEvenWhileRestricted(t) {
    this.St(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.qt(t);
  }
  enterRestrictedMode(t) {
    if (!this.Pt) {
      this.Pt = true, this.Nt = t || false;
      const e = _s();
      e && "function" == typeof e.removeEventListener && e.removeEventListener("visibilitychange", this.xt);
    }
  }
  enqueue(t) {
    if (this.St(), this.Pt)
      return new Promise(() => {
      });
    const e = new j();
    return this.qt(() => this.Pt && this.Nt ? Promise.resolve() : (t().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t) {
    this.enqueueAndForget(() => (this.Rt.push(t), this.Ot()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async Ot() {
    if (0 !== this.Rt.length) {
      try {
        await this.Rt[0](), this.Rt.shift(), this.vt.reset();
      } catch (t) {
        if (!/**
        * @license
        * Copyright 2017 Google LLC
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *   http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        /** Verifies whether `e` is an IndexedDbTransactionError. */
        function(t2) {
          return "IndexedDbTransactionError" === t2.name;
        }(t))
          throw t;
        y("AsyncQueue", "Operation failed with retryable error: " + t);
      }
      this.Rt.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.vt.J(() => this.Ot());
    }
  }
  qt(t) {
    const e = this.Tt.then(() => (this.Dt = true, t().catch((t2) => {
      this.$t = t2, this.Dt = false;
      const e2 = (
        /**
        * Chrome includes Error.message in Error.stack. Other browsers do not.
        * This returns expected output of message + stack when available.
        * @param error - Error or FirestoreError
        */
        function(t3) {
          let e3 = t3.message || "";
          t3.stack && (e3 = t3.stack.includes(t3.message) ? t3.stack : t3.message + "\n" + t3.stack);
          return e3;
        }(t2)
      );
      throw g("INTERNAL UNHANDLED ERROR: ", e2), t2;
    }).then((t2) => (this.Dt = false, t2))));
    return this.Tt = e, e;
  }
  enqueueAfterDelay(t, e, n) {
    this.St(), // Fast-forward delays for timerIds that have been overriden.
    this.Ft.indexOf(t) > -1 && (e = 0);
    const r = vs.createAndSchedule(this, t, e, n, (t2) => this.kt(t2));
    return this.Vt.push(r), r;
  }
  St() {
    this.$t && b();
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async Ct() {
    let t;
    do {
      t = this.Tt, await t;
    } while (t !== this.Tt);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Lt(t) {
    for (const e of this.Vt)
      if (e.timerId === t)
        return true;
    return false;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  Mt(t) {
    return this.Ct().then(() => {
      this.Vt.sort((t2, e) => t2.targetTimeMs - e.targetTimeMs);
      for (const e of this.Vt)
        if (e.skipDelay(), "all" !== t && e.timerId === t)
          break;
      return this.Ct();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  Ut(t) {
    this.Ft.push(t);
  }
  /** Called once a DelayedOperation is run or canceled. */
  kt(t) {
    const e = this.Vt.indexOf(t);
    this.Vt.splice(e, 1);
  }
};
var Es = class {
  /** @hideconstructor */
  constructor(t, e) {
    this._firestore = t, this._transaction = e, this._dataReader = Zn(t);
  }
  /**
   * Reads the document referenced by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be read.
   * @returns A `DocumentSnapshot` with the read data.
   */
  get(t) {
    const e = ws(t, this._firestore), n = new Kr(this._firestore);
    return this._transaction.lookup([e._key]).then((t2) => {
      if (!t2 || 1 !== t2.length)
        return b();
      const r = t2[0];
      if (r.isFoundDocument())
        return new yr(this._firestore, n, r.key, r, e.converter);
      if (r.isNoDocument())
        return new yr(this._firestore, n, e._key, null, e.converter);
      throw b();
    });
  }
  set(t, e, n) {
    const r = ws(t, this._firestore), s = Gr(r.converter, e, n), i = Jn(this._dataReader, "Transaction.set", r._key, s, null !== r.converter, n);
    return this._transaction.set(r._key, i), this;
  }
  update(t, e, n, ...r) {
    const s = ws(t, this._firestore);
    let i;
    return i = "string" == typeof (e = getModularInstance(e)) || e instanceof Un ? or(this._dataReader, "Transaction.update", s._key, e, n, r) : ir(this._dataReader, "Transaction.update", s._key, e), this._transaction.update(s._key, i), this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `Transaction` instance. Used for chaining method calls.
   */
  delete(t) {
    const e = ws(t, this._firestore);
    return this._transaction.delete(e._key), this;
  }
};
function As(t, e, n) {
  const r = An(t = ct(t, Tn)), s = Object.assign(Object.assign({}, ys), n);
  !function(t2) {
    if (t2.maxAttempts < 1)
      throw new U(P, "Max attempts must be at least 1");
  }(s);
  const i = new j();
  return new gs(new bs(), r, s, (n2) => e(new Es(t, n2)), i).run(), i.promise;
}
!function(t) {
  w = t;
}(`${SDK_VERSION}_lite`), _registerComponent(new Component("firestore/lite", (t, { instanceIdentifier: e, options: n }) => {
  const r = t.getProvider("app").getImmediate(), s = new Tn(new W(t.getProvider("auth-internal")), new H(t.getProvider("app-check-internal")), function(t2, e2) {
    if (!Object.prototype.hasOwnProperty.apply(t2.options, ["projectId"]))
      throw new U(P, '"projectId" not provided in firebase.initializeApp.');
    return new J(t2.options.projectId, e2);
  }(r, e), r);
  return n && s._setSettings(n), s;
}, "PUBLIC").setMultipleInstances(true)), // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation
registerVersion("firestore-lite", "3.9.0", ""), registerVersion("firestore-lite", "3.9.0", "esm2017");
export {
  Dn as AggregateField,
  Nn as AggregateQuerySnapshot,
  Mn as Bytes,
  Sn as CollectionReference,
  Fn as DocumentReference,
  yr as DocumentSnapshot,
  Un as FieldPath,
  Bn as FieldValue,
  Tn as Firestore,
  U as FirestoreError,
  zn as GeoPoint,
  xn as Query,
  Pr as QueryCompositeFilterConstraint,
  Ar as QueryConstraint,
  gr as QueryDocumentSnapshot,
  Cr as QueryEndAtConstraint,
  Tr as QueryFieldFilterConstraint,
  Fr as QueryLimitConstraint,
  Dr as QueryOrderByConstraint,
  _r as QuerySnapshot,
  qr as QueryStartAtConstraint,
  St as Timestamp,
  Es as Transaction,
  ds as WriteBatch,
  ts as addDoc,
  os as aggregateFieldEqual,
  us as aggregateQuerySnapshotEqual,
  $r as and,
  ls as arrayRemove,
  hs as arrayUnion,
  ss as average,
  qn as collection,
  On as collectionGroup,
  Vn as connectFirestoreEmulator,
  is as count,
  Xr as deleteDoc,
  cs as deleteField,
  kn as doc,
  jn as documentId,
  Mr as endAt,
  Lr as endBefore,
  ns as getAggregate,
  es as getCount,
  Yr as getDoc,
  Hr as getDocs,
  Pn as getFirestore,
  fs as increment,
  Rn as initializeFirestore,
  xr as limit,
  Sr as limitToLast,
  Vr as or,
  Nr as orderBy,
  Ir as query,
  Ln as queryEqual,
  Cn as refEqual,
  As as runTransaction,
  as as serverTimestamp,
  Zr as setDoc,
  p as setLogLevel,
  vr as snapshotEqual,
  kr as startAfter,
  Or as startAt,
  rs as sum,
  $n as terminate,
  Jr as updateDoc,
  Rr as where,
  ms as writeBatch
};
/*! Bundled license information:

@firebase/firestore/dist/lite/index.browser.esm2017.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
  * @license
  * Copyright 2018 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *)
*/
//# sourceMappingURL=firebase_firestore_lite.js.map
